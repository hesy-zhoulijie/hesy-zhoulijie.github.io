{"posts":[{"title":"VS Code指北","content":"VS Code指北 7/25 15:17 更新： 由于洛谷粘贴代码的格式问题，按照本文之前的代码配置tasks.json和launch.json报错(所有$后都出现了一个空格)，请重新复制代码。 这个问题的出现是我本人审校不认真所造成的。在此我对各位读者和洛谷日报的负责人员表示歉意。 Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，使用Web技术Electron搭建，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展。软件跨平台支持 Windows、Mac 以及 Linux。 接触这款编辑器之后的感受正如VSCode官网所述：VSCode Redefined Code Editing.这款编辑器带来的强大的功能是Dev-C++等古董编辑器望尘莫及的。 目录 安装VSCode 开始编辑代码 编辑器基本设置 键盘快捷键配置 如何调试代码 &amp; 一个sample &amp; C++补全 美化VSCode 插件入门: Hello,World 安装VSCode 在VSCode官网可以get不同版本的VSCode安装程序。其中Stable为稳定版，Insiders为测试版。选择你喜欢的版本下载即可。 Windows用户安装VSC时可以选择把VSC注册到path。也可以加入到右键菜单，方便打开文件。 终端可以使用code命令启动VSC。 开始编辑代码 VSC是长这个样子的： 侧边栏可以管理调试、打开文件、管理扩展、搜索、管理源码 右下角的一排选项可以更改正在编辑的文件的格式。 “哇，看起来好高级的样子！” 你激动的创建新文件并写下了helloworld。 但是好像发生了一些奇怪的事情…… 怎么没有高亮啊喂！？ 嘿嘿，其实正确的打开方式是这样的： 可以在右下角点击纯文本并修改为C++ 也可以在保存文件时更改后缀为.cpp 那这不也太麻烦了？！ 不要着急~一会你就知道更简便的方法了。 编辑器基本设置 从左下角可以打开设置界面。 啊喂？！这个设置界面怎么和Dev-C++的不一样啊？这是什么鬼？ 其实VSC的设置是一个.json文件，可以通过修改参数的方法更改设置。 左侧是默认设置，右侧是用户自定义设置。 我们试着修改一个设置，比如给滚动添加动画 在上面的搜索框输入scroll或者打开编辑器找到它： 点击最左面的铅笔图标，将参数修改为true（这时你可以看到右侧会多出一行代码）并按下Ctrl+S保存设置，我们就修改完成了！ 大部分设置都是这样修改的，少部分需要输入几个参数。设置都附有注释（不过部分是英文的，TAT）。下面是我的设置： 还记得我们提到的代码格式问题吗？搜索defaultLanguage，将这个设置修改为cpp即可~ 顺带一提，你会偷偷发现上面出现了Settings (Preview)这个选项卡。这是VSC的新版设置界面（和现在的这个不太一样），有兴趣的同学可以自己研究一下。 键盘快捷键配置 键盘快捷键的设置也在左下角的设置按钮里。打开之后可以看到上图的界面。 默认的快捷键非常方便，我没有修改快捷键。 这里给出几组最常用的快捷键，可以大幅度提高效率（灵活使用甚至可以丢掉鼠标写代码）： 编辑器与窗口管理 打开 Ctrl+O 新窗口 Ctrl+Shift+N 新标签页 Ctrl+N 关闭整个VSC窗口 Ctrl+Shift+W 关闭当前标签页 Ctrl+W 重新打开刚刚关闭的标签页 Ctrl+Shift+T 切换标签页 Ctrl+Tab 创建一个新编辑器并将当前页面复制过去 Ctrl+\\ 在前三个编辑器之间切换 Ctrl+1 2 3 将焦点编辑器移动位置 先按下 Ctrl+K 左下角出现提示后用 ← → 移动 或者可以 Ctrl+Alt+←→ 在标签页之间切换 Alt+1~9 代码编辑 搜索 Ctrl+F 替换 Ctrl+H 复制光标所在行 只需按下Ctrl+C即可。 去掉行尾空格 Ctrl+K 然后 Ctrl+X 切换行注释(可多行) Ctrl+/ 代码缩进 Ctrl+[ 或 Ctrl+] 当前行上下移动 Alt+↑↓ 当前行后插入一行 Ctrl+Enter 当前行前插入一行 Ctrl+Shift+Enter 选中下一行 Ctrl+i (神级辅助键) 撤销光标上次移动 Ctrl+U 选中下个高亮的匹配项 Ctrl+D 多光标模式 Atl+鼠标单击即可在单击处创建新的光标 (这个模式非常灵活，可以搭配多种操作提高效率) (神级辅助键) 速览定义 Alt+F12 转到定义 F12 Zen模式(一个奇怪的类似全屏的模式) Ctrl+K 然后 Z 打开自动保存 Ctrl+Shift+P之后输入AutoSave，选中，按下回车。 打开终端 Ctrl+~ 还有一个炒鸡强大的按键： 鼠标中键 我的鼠标滚轮能按下去？ 对！它非常的好用。 按住鼠标中键并选择=Alt+Shift选择 （既选择矩形区域） 用鼠标中键关闭编辑器/选项卡/通知：在空编辑器/选项卡/通知条任意位置按下中键即可 再也不用对准×号了有木有！？ 调试代码 再怎么说它也只是一个Editor！怎么调试代码呢？ VSC的插件很强大。这里我们使用一个插件。 打开插件商店，搜索C/C++ Compile Run并安装。 同样的方法可以安装C++辅助插件C/C++（这个是微软官方的插件） 安装完成，重启VSC后马上可以使用，按F6就可以偷税的调试当前的单文件C++代码了。但是…… 我是Windows，好像报错了，怎么办？ (7/25 15:19更新:) 由于部分平台使用的终端默认为Windows Powershell,因此不需要更改即可使用插件，请自行尝试是否需要更改。 对于Windows用户，这个插件不尽人意，我们需要稍微魔改一下： VSC的插件目录在C:\\User\\(your username)\\.vscode\\extensions\\ 我们找到一个叫danielpinto8zz6.c-cpp-compile-run-0.0.6的文件夹，在里面的out文件夹里有一个extension.js，用VSC打开它。 你可以像我一样修改图中这几行。如果你是js大佬，你可以进行更精彩的修改。 改好了，但是还是显示错误? path里没有g++的路径！ 下载MinGW 需要下载MinGW（注意选择对应的位数）安装并将g++.exe的路径添加到path。 去搜索MinGW并下载： 你会得到一个奇怪的玩意儿： 勾选图中几个并选择Apply即可下载了。 添加路径到Path 按下Win+Pause/Break两个键并打开左侧的高级系统设置，找到环境变量。 编辑图中的那一项。添加路径比如默认安装路径C:\\MinGW\\bin。注意前面的分号。 记的还要重启VSC哦。 利用VScode写题目 这算啥啊，可不可以show一下VSC的强大呢？ 那我就用一个例子 [JLOI2009]神秘的生物来证明VSC的强大！ 首先用VSC打开工作写题文件夹。文件(F)-&gt;打开文件夹 打开你的文件夹 (也可以直接创建文件，区别在于不打开文件夹无法用F5调试，但是可以用上文的插件调试) Ctrl+N新建一个文件保存到此文件夹，打开文件自动保存。 头文件补全，非常方便 感觉哪儿不对……？速览定义！ 使用小地图和大纲快速定位 使用多光标模式修改 如果按照上一步配置好了，可以用F6快速运行代码。 附：F5 Debug的配置方法 准备好一个工作文件夹，以后就用这个文件夹写代码 文件(F)-&gt;打开文件夹 打开你的文件夹 写一个程序保存到这个打开的文件夹 按下F5并选择GDB 用以下内容替换launch.json,注意miDebuggerPath要换成自己的GDB路径，还要记得\\是要用\\\\代替哦~ 点我 再次F5，点击配置任务，选择使用模板创建，随便选一个模板。 用以下内容替换tasks.json 点我 你会看到： 嗯，可以F5调试啦！用GDB的同学可以尝试用以下内容覆盖launch.json和tasks.json 点我 然后F5即可！ 附：C++补全 来体验一下VSC的强大插件吧！ 搜索C/C++ Clang Command Adapter并安装插件 如果你没有安装Clang，那么可以装一个： Download 然后记得像GDB一样把bin添加到PATH里去。 最后，打开设置，在用户设置里添加如下内容(C++)： &quot;clang.executable&quot;: &quot;clang&quot;, &quot;clang.completion.enable&quot;: true, &quot;clang.cxxflags&quot;: [ &quot;-std=c++11&quot;, &quot;-IC:/MinGW/lib/gcc/mingw32/6.3.0/include/c++&quot; ] 嗯，上面的&quot;-IC:/MinGW/lib/gcc/mingw32/6.3.0/include/c++&quot;头文件路径要换成自己的。 还可以用MinGW的头文件？ 对，就是有这种操作。 美化VSC VSC自带多款图标和配色。在插件商店也能找到更多的配色。由于各人口味不同，这里就不安利啦~ （想要Sublime和Atom theme的童鞋们可以安装这两个theme) 我后来换成了One-Dark-Pro，感觉很清爽。 一个简易插件 既然已经说了这么多，我们也不妨探讨一下VSCode的插件是怎么烤出来的…… [Official]Your first VSCode extension 首先当然是安装nodejs辣！ Node.js.org 然后npm install -g yo generator-code (这个过程巨慢，为了消磨时间，可以把[JLOI2009]神秘的生物切掉……) yo code既可开始搭建插件。 然后我们输入2选择第二项JavaScript 然后起名字~比如Hello 然后等一会它会提示让你打开创建的插件目录。 附带的markdown文档 (插件：Markdown Preview Enhanced) 如果只是本地做做demo，你会发现这些其实没用，可以删掉。（quickstart里有说test是测试用的） F5可以调试插件！ 在弹出的扩展开发主机中按F1调出命令条并输入Hello World，就可以运行这个插件啦qwq 以上就是VSC编写竞赛代码的基本食用方法，感谢大家阅读本文，也祝大家玩用的愉快~ ","link":"https://hesy-zhoulijie.github.io/vscode/"},{"title":"码风规范","content":"码风规范 本文介绍本人在 OI 中常用的代码规范。 所有的 #include 指令必须放置于整个程序开头。 不应该使用 using namespace std;。 main 函数应该放置于整个程序末尾。 不应该使用 int 代替 bool 表示逻辑值。 预编译指令 #include 中，C 标准库头文件必须使用 c 前缀，而不是 .h 后缀。 #include 中，C 标准库头文件应该放置于 C++ 标准库头文件前，其它头文件（如果有）应放置于最后。 所有的预编译指令（包括 #ifdef 等）不能缩进。 缩进 对于每个代码块，使用 4 空格或等长的 Tab 缩进。 花括号 花括号必须遵循以下两种写法之一，前一种被称为「花括号不换行」，后一种被称为「花括号换行」。 对于「花括号不换行」，左花括号的左边必须有且仅有一个空格。 对于「花括号换行」，左花括号必须与上一级代码块的缩进相同。 所有右花括号必须与上一级代码块的缩进相同。 // 1 if (condition) { } else { } // 2 if (condition) { } else { } 行 除 for 中的三个语句外，每行不能有超过一个语句。如果需要一行内求值多个表达式，可以使用等效的逗号表达式替代。 多个意义独立的代码块之间应该用空行隔开。 右花括号前不应该有多余的空行。 不应该有两个连续的空行。 非空行尾不应该有多余的空格。 所有的 #include 指令之后必须有一个空行。 如果有 using namespace std;，则必须紧跟在 #include 后的空行后，之后必须一个空行。 函数、成员函数、结构体、全局变量块之间必须用空行隔开。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100; const int MAXM = 200; int n, m, a[MAXN + 1]; double p, q, x, y; int main() { p = 1, q = 2; return 0; } 函数 main 函数的返回值类型必须是 int，可以省略 return 0;。 空函数体可以使用 {}。 传参时，应该根据实际需要使用「引用」、「const 引用」和「值传递」。 变量 应该尽量少使用全局变量。 局部变量必须在用时定义，变量名不应该与上一个块中的变量重名，可以与全局变量重名。 只在一个函数内使用到的需要全局空间（如大数组）或生命周期的变量，必须定义为 static 的局部变量。 空格 逗号 , 与 for 中的分号 ; 后面必须有一个空格，前面不能有空格。 左圆（方）括号后、右圆（方）括号前，在书写长表达式时，为了便于阅读，可以加一个空格，如 f[i][j] = f[ f[i][j - 1] ][j - 1] 双目运算符、三目运算符的两侧必须有一个空格。 单目运算符的两侧不能有空格。 冒号的两侧必须有一个空格。 struct Edge { int x; Edge() : x(0) {} } 流程控制关键字之后，左圆括号前必须有一个空格，函数名之后，左圆括号前不能有空格。 对于「花括号不换行」，do-while 结构的 do 之后，左花括号前必须有一个空格，while 前必须有一个空格。 模板参数表中，如果右方括号前不得不加一个空格，则可以在对应的左方括号后加一个空格，为了对称。 .、-&gt;、:: 的两边不能有空格。 指针与引用 在描述类型名时，指针符号 * 和引用符号 &amp; 与左侧的类型名之间必须有一个空格，与右侧的其它关键字之间不能有空格，如 char *const 或 int *&amp;。 在定义变量、函数返回值、参数时，指针符号 * 和引用符号 &amp; 与左侧的类型名之间必须有一个空格，与右侧的变量、函数、参数名之间不能有空格。 命名 所有结构体、函数、变量、参数名必须使用驼峰命名法，其中结构体名首字母必须大写，其它首字母必须小写。 为方便，命名中的单词可以使用缩写，函数、变量、参数名可以用一个小写字母代替。全局数组可以命名为一个大写字母。 int aVarWithVeryLongName; struct Node { int dep, s; } struct SegT { SegT *lc, *rc; } bool getAns(std::vector&lt;std::string&gt; &amp;res); ","link":"https://hesy-zhoulijie.github.io/code-format/"},{"title":"CSP-JS 算法集大成","content":"CSP-JS 算法集大成 内容来自洛谷,侵删 并查集 update:2020.2.13 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受;即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间(1~3秒)内计算出试题需要的结果，只能用并查集来描述。 (摘自百度) 关于并查集和路径压缩： 现在我们假定 f[i] 表示第 i 个人的老大是谁。 现在我们有甲，乙，丙三个人（分别用 a, b, c 表示） 假设甲和乙打架了，甲做了丙的小弟。则有 f[a]=b， 后来甲打赢了丙 那么丙就是甲的小弟了。有 f[c]=a， 但是如果我们这样表示，丙不能直接知道甲，容易自己人打自己人 所以，我们必须直接让丙的大哥变成最大的老大。 定义函数 find int find(int k){ if(f[k]==k)return k; return find(f[k]); }//find 函数可以直接找到最大的老大 f[c]=find(a); //丙的老大是甲 这时，因为我们要路过他所有的上级，我们也可以顺便使途中经过的人的大哥也变成老大。 //路径压缩 int find(int k){ if(f[k]==k)return k; return f[k]=find(f[k]); /* 即： f[k]=find(f[k]); return f[k]; */ } f[c]=find(a); 简直是太巧妙了！ 而判定两个人的老大是否相等，只需 if(find(a)==find(b)) 就好了。 一些设定： 一个人不能有两个老大。 当已经有老大的人臣服时，老大也将成为胜利的人的小弟。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int i,j,k,n,m,s,ans,f[10010],p1,p2,p3; //f[i]表示i的集合名 int find(int k){ //路径压缩 if(f[k]==k)return k; return f[k]=find(f[k]); } int main() { cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) f[i]=i;//初始化i的老大为自己 for(i=1;i&lt;=m;i++){ cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3; if(p1==1) f[find(p2)]=find(p3); //p3打赢了p2 else if(find(p2)==find(p3)) //是否是一伙的 printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } return 0; } 快速幂 【算法思路】 对于一个数的n次幂，我们可以将它进行拆解，在这里以2^15为例： step1.答案等于 15 个 2 相乘. step2.答案等于 7 个 4 相乘再乘上一个 2. step3.答案等于 3 个 16 相乘再乘上 24. step4.答案等于 1 个 256 乘上 24*16. 从以上的步骤中不难看出，当我们求一个数的n次幂的时候，我们可以将它的两两进行配对相乘，如果有多出来的一个数，则将它乘到答案中，否则继续配对，直到只剩下一个数为止。有一个小的注意事项，对答案进行初始化时，初始值应为1而不是0. 【注意事项】 1、每进行一步运算时都要把得到的答案对p取模，否则会只有 28分。 2、b m p ans 都要定义成 long long 型变量，不然会只有 42分。 3、不要认为运算过程中对答案取模就够了，再输出答案的时候不要忘记把最终的答案再对p取一次模，否则就会只有 84分。 4、结合以上几点注意事项的快速幂程序就可以得到 100分了。 【代码】 #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ long long ans=1,i,j,k,m,n,b,p; scanf(&quot;%lld%lld%lld&quot;,&amp;b,&amp;m,&amp;p); printf(&quot;%lld^%lld mod %lld=&quot;,b,m,p); while(m&gt;0){ if(m%2==1) ans=ans*b%p; b=b*b%p; m=m&gt;&gt;1; } printf(&quot;%lld&quot;,ans%p); return 0; } 欧拉筛 想要快速地筛出一定上限内的素数？ 下面这种方法可以保证范围内的每个合数都被删掉（在 bool 数组里面标记为非素数），而且任一合数只被： “最小质因数 × 最大因数（非自己） = 这个合数” 的途径删掉。由于每个数只被筛一次，时间复杂度为 O(n)O(n)O(n)。 先浏览如何实现再讲其中的原理。 实现 #include &lt;cstdio&gt; #include &lt;cstring&gt; bool isPrime[100000010]; //isPrime[i] == 1表示：i是素数 int Prime[6000010], cnt = 0; //Prime存质数 void GetPrime(int n)//筛到n { memset(isPrime, 1, sizeof(isPrime)); //以“每个数都是素数”为初始状态，逐个删去 isPrime[1] = 0;//1不是素数 for(int i = 2; i &lt;= n; i++) { if(isPrime[i])//没筛掉 Prime[++cnt] = i; //i成为下一个素数 for(int j = 1; j &lt;= cnt &amp;&amp; i*Prime[j] &lt;= n/*不超上限*/; j++) { //从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数 //当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的 isPrime[i*Prime[j]] = 0; if(i % Prime[j] == 0)//i中也含有Prime[j]这个因子 break; //重要步骤。见原理 } } } int main() { int n, q; scanf(&quot;%d %d&quot;, &amp;n, &amp;q); GetPrime(n); while (q--) { int k; scanf(&quot;%d&quot;, &amp;k); printf(&quot;%d\\n&quot;, Prime[k]); } return 0; } 原理概述 代码中，外层枚举 i=1→ni = 1 \\to ni=1→n。对于一个 iii，经过前面的腥风血雨，如果它还没有被筛掉，就加到质数数组 Prime[]Prime[]Prime[] 中。下一步，是用 iii 来筛掉一波数。 内层从小到大枚举 Prime[j]Prime[j]Prime[j]。 i×Prime[j]i×Prime[j]i×Prime[j] 是尝试筛掉的某个合数，其中，我们期望 Prime[j]Prime[j]Prime[j] 是这个合数的最小质因数 (这是线性复杂度的条件，下面叫做“筛条件”)。它是怎么得到保证的？ jjj 的循环中，有一句就做到了这一点： if(i % Prime[j] == 0) break; jjj 循环到 imod Prime[j]==0i \\mod Prime[j] == 0imodPrime[j]==0 就恰好需要停止的理由是： 下面用 s(smaller)s(smaller)s(smaller) 表示小于 jjj 的数， L(larger)L(larger)L(larger) 表示大于 jjj 的数。 ① iii 的最小质因数肯定是 Prime[j]Prime[j]Prime[j]。 （如果 iii 的最小质因数是 Prime[s]Prime[s]Prime[s] ，那么 Prime[s]Prime[s]Prime[s] 更早被枚举到（因为我们从小到大枚举质数），当时就要break） 既然 iii 的最小质因数是 Prime[j]Prime[j]Prime[j]，那么 i×Prime[j]i × Prime[j]i×Prime[j] 的最小质因数也是 Prime[j]Prime[j]Prime[j]。所以， jjj 本身是符合“筛条件”的。 ② i×Prime[s]i × Prime[s]i×Prime[s] 的最小质因数确实是 Prime[s]Prime[s]Prime[s]。 （如果是它的最小质因数是更小的质数 Prime[t]Prime[t]Prime[t]，那么当然 Prime[t]Prime[t]Prime[t] 更早被枚举到，当时就要break） 这说明 jjj 之前（用 i×Prime[s]i × Prime[s]i×Prime[s] 的方式去筛合数，使用的是最小质因数）都符合“筛条件”。 ③ i×Prime[L]i × Prime[L]i×Prime[L] 的最小质因数一定是 Prime[j]Prime[j]Prime[j]。 （因为 iii 的最小质因数是 Prime[j]Prime[j]Prime[j]，所以 i×Prime[L]i × Prime[L]i×Prime[L] 也含有 Prime[j]Prime[j]Prime[j] 这个因数（这是 iii 的功劳），所以其最小质因数也是 Prime[j]Prime[j]Prime[j]（新的质因数 Prime[L]Prime[L]Prime[L] 太大了）） 这说明，如果 jjj 继续递增（将以 i×Prime[L]i × Prime[L]i×Prime[L] 的方式去筛合数，没有使用最小质因数），是不符合“筛条件”的。 小提示： 当 iii 还不大的时候，可能会一层内就筛去大量合数，看上去耗时比较大，但是由于保证了筛去的合数日后将不会再被筛（总共只筛一次），复杂度是线性的。到 iii 接近 nnn 时，每层几乎都不用做什么事。 建议看下面两个并不复杂的证明，你能更加信任这个筛法，利于以后的扩展学习。 正确性（所有合数都会被标记）证明 设一合数 CCC（要筛掉）的最小质因数是 p1p_1p1​，令 B=C/p1B = C / p_1B=C/p1​（ C=B×p1C = B × p_1C=B×p1​），则 BBB 的最小质因数不小于 p1p_1p1​（否则 CCC 也有这个更小因子）。那么当外层枚举到 i=Bi = Bi=B 时，我们将会从小到大枚举各个质数；因为 i=Bi = Bi=B 的最小质因数不小于 p1p_1p1​，所以 iii 在质数枚举至 p1p_1p1​ 之前一定不会break，这回， CCC 一定会被 B×piB × p_iB×pi​ 删去。 核心：亲爱的 BBB 的最小质因数必不小于 p1p_1p1​。 例： 315=3×3×5×7315 = 3 × 3 × 5 × 7315=3×3×5×7，其最小质因数是 333。考虑 i=315/3=105i = 315 / 3 = 105i=315/3=105 时，我们从小到大逐个枚举质数，正是因为 iii 的最小质因数也不会小于 333（本例中就是 333），所以当枚举 j=1(Prime[j]=2)j = 1 (Prime[j] = 2)j=1(Prime[j]=2) 时， iii 不包含 222 这个因子，也就不会break，直到 Prime[j]=3Prime[j] = 3Prime[j]=3 之后才退出。 当然质数不能表示成“大于1的某数×质数”，所以整个流程中不会标记。 线性复杂度证明 注意这个算法一直使用“某数×质数”去筛合数，又已经证明一个合数一定会被它的最小质因数 p1p_1p1​ 筛掉，所以我们唯一要担心的就是同一个合数是否会被“另外某数 × p1p_1p1​ 以外的质数”再筛一次导致浪费时间。设要筛的合数是 CCC，设这么一个作孽的质数为 pxp_xpx​，再令 A=C/pxA = C / p_xA=C/px​，则 AAA 中一定有 p1p_1p1​ 这个因子。当外层枚举到 i=Ai = Ai=A，它想要再筛一次 CCC，却在枚举 Prime[j]=p1Prime[j] = p_1Prime[j]=p1​ 时，因为 imod Prime[j]==0i \\mod Prime[j] == 0imodPrime[j]==0 就退出了。因而 CCC 除了 p1p_1p1​ 以外的质因数都不能筛它。 核心：罪恶的 AAA 中必有 p1p_1p1​ 这个因子。 例： 315=3×3×5×7315 = 3 × 3 × 5 × 7315=3×3×5×7。首先，虽然看上去有两个 333，但我们筛数的唯一一句话就是 isPrime[i*Prime[j]] = 0; 所以， 315315315 只可能用 105×3105 × 3105×3 或 63×563 × 563×5 或 45×745 × 745×7 这三次筛而非四次。然后，非常抱歉，后两个 i=63,i=45i = 63, i = 45i=63,i=45 都因为贪婪地要求对应的质数 Prime[j]Prime[j]Prime[j] 为 555 、 777，而自己被迫拥有 333 这个因数，因此他们内部根本枚举不到 555 、 777，而是枚举到 333 就break了。 以上两个一证，也就无可多说了。 Dijkstra 详解 前言 SPFASPFASPFA算法由于它上限 O(NM)=O(VE)O(NM) = O(VE)O(NM)=O(VE)的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法: dijkstradijkstradijkstra. 什么是 dijkstradijkstradijkstra? dijkstradijkstradijkstra是一种单源最短路径算法,时间复杂度上限为 O(n2)O(n^2)O(n2)(朴素),在实际应用中较为稳定 ;;;加上堆优化之后更是具有 O((n+m)log⁡2n)O((n+m)\\log_{2}n)O((n+m)log2​n)的时间复杂度,在稠密图中有不俗的表现. dijkstradijkstradijkstra的原理/流程? dijkstradijkstradijkstra本质上的思想是贪心,它只适用于不含负权边的图. 我们把点分成两类,一类是已经确定最短路径的点,称为&quot;白点&quot;,另一类是未确定最短路径的点,称为&quot;蓝点&quot; dijkstradijkstradijkstra的流程如下 ::: 1.1.1. 初始化 dis[start]=0,dis[start] = 0,dis[start]=0,其余节点的 disdisdis值为无穷大. 2.2.2. 找一个 disdisdis值最小的蓝点 x,x,x,把节点 xxx变成白点. 3.3.3. 遍历 xxx的所有出边 (x,y,z),(x,y,z),(x,y,z),若 dis[y]&gt;dis[x]+z,dis[y] &gt; dis[x] + z,dis[y]&gt;dis[x]+z,则令 dis[y]=dis[x]+zdis[y] = dis[x] + zdis[y]=dis[x]+z 4.4.4. 重复 2,32,32,3两步,直到所有点都成为白点 ... 时间复杂度为 O(n2)O(n^2)O(n2) dijkstradijkstradijkstra为什么是正确的 当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第 222步中找出的蓝点 xxx必然满足 :dis[x]:dis[x]:dis[x]已经是起点到 xxx的最短路径 ...我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度 图解 (令 start=1start = 1start=1) 开始时我们把 dis[start]dis[start]dis[start]初始化为 000,其余点初始化为 infinfinf 第一轮循环找到 disdisdis值最小的点 111,将 111变成白点,对所有与 111相连的蓝点的 disdisdis值进行修改,使得 dis[2]=2,dis[3]=4,dis[4]=7dis[2]=2,dis[3]=4,dis[4]=7dis[2]=2,dis[3]=4,dis[4]=7 第二轮循环找到 disdisdis值最小的点 222,将 222变成白点,对所有与 222相连的蓝点的 disdisdis值进行修改,使得 dis[3]=3,dis[5]=4dis[3]=3,dis[5]=4dis[3]=3,dis[5]=4 第三轮循环找到 disdisdis值最小的点 333,将 333变成白点,对所有与 222相连的蓝点的 disdisdis值进行修改,使得 dis[4]=4dis[4]=4dis[4]=4 接下来两轮循环分别将 4,54,54,5设为白点,算法结束,求出所有点的最短路径 时间复杂度 O(n2)O(n^2)O(n2) 为什么 dijkstradijkstradijkstra不能处理有负权边的情况? 我们来看下面这张图 222到 333的边权为 −4-4−4,显然从 111到 333的最短路径为 −2-2−2 (1−&gt;2−&gt;3).(1-&gt;2-&gt;3).(1−&gt;2−&gt;3).但在循环开始时程序会找到当前 disdisdis值最小的点 333,并标记它为白点. 这时的 dis[3]=1,dis[3]=1,dis[3]=1,然而 111并不是起点到 333的最短路径.因为 333已经被标为白点,所以 dis[3]dis[3]dis[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. dijkstradijkstradijkstra的堆优化? 观察 dijkstradijkstradijkstra的流程,发现步骤 222可以优化 怎么优化呢? 我会zkw线段树!我会斐波那契堆! 我会堆! 我们可以用堆对 disdisdis数组进行维护,用 O(log⁡2n)O(\\log_{2}n)O(log2​n)的时间取出堆顶元素并删除,用 O(log⁡2n)O(\\log_{2}n)O(log2​n)遍历每条边,总复杂度 O((n+m)log⁡2n)O((n+m)\\log_{2}n)O((n+m)log2​n) 范例代码: #include&lt;bits/stdc++.h&gt; const int MaxN = 100010, MaxM = 500010; struct edge { int to, dis, next; }; edge e[MaxM]; int head[MaxN], dis[MaxN], cnt; bool vis[MaxN]; int n, m, s; inline void add_edge( int u, int v, int d ) { cnt++; e[cnt].dis = d; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt; } struct node { int dis; int pos; bool operator &lt;( const node &amp;x )const { return x.dis &lt; dis; } }; std::priority_queue&lt;node&gt; q; inline void dijkstra() { dis[s] = 0; q.push( ( node ){0, s} ); while( !q.empty() ) { node tmp = q.top(); q.pop(); int x = tmp.pos, d = tmp.dis; if( vis[x] ) continue; vis[x] = 1; for( int i = head[x]; i; i = e[i].next ) { int y = e[i].to; if( dis[y] &gt; dis[x] + e[i].dis ) { dis[y] = dis[x] + e[i].dis; if( !vis[y] ) { q.push( ( node ){dis[y], y} ); } } } } } int main() { scanf( &quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s ); for(int i = 1; i &lt;= n; ++i)dis[i] = 0x7fffffff; for( register int i = 0; i &lt; m; ++i ) { register int u, v, d; scanf( &quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;d ); add_edge( u, v, d ); } dijkstra(); for( int i = 1; i &lt;= n; i++ ) printf( &quot;%d &quot;, dis[i] ); return 0; } 最小生成树 有两个算法： kruskalkruskalkruskal与 PrimPrimPrim 这两种算法是最小生成树的算法中最常用的算法~~（因为我不知道别的算法……）~~ kruskalkruskalkruskal主要思路： 输入边，用结构体储存 用结构体快排以边比较从小到大快排 建一个并查集，并初始化并查集（并查集代表两个点有没有在同一个树里面） 设边edge[100000],edge.start一个点，edge.to另一个点，edge.val是边长，ans是最终答案。 for(i=1;i&lt;=m（边数）;i++)找一条边edge[i],若edge[i].start与edge[i].to不在同一个并查集里面，就将edge[i].start与edge[i].to所在的并查集合并，并将ans+=edge[i].val。 若在同一个并查集，则跳过这次循环。因为如果这两个点连接起来，就会形成一个环。 {若1与3连起来，就会造成一个环。} 最后一步：printf(&quot;%d&quot;,ans); 解释： 快排边长，是为了让每次选的都是所有连接中都能是边长最小的（贪心思想） 并查集的作用是：判断有没有连成一个环。若两个点在同一个并查集里面，则说明它们在同一个树里，若连接，就会造成一个环 当到了已连边的个数是点的个数-1时，就要停止循环，因为这个时候，最小生成树已经完成了，所有的并查集都连在了一起。 下面是点为5时的情况 以下是本人的代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; int n,m,i,j,u,v,total; struct edge{ int start,to;long long val; }bian[2000005]; int f[100000]; long long ans; int find(int x)//并查集部分 { if (f[x]==x) return x; else { f[x]=find(f[x]); return f[x]; } } bool cmp(edge a,edge b)//结构体快排时用到的 { return a.val&lt;b.val; } inline void kruskal()//最小生成树 { for(int i=1;i&lt;=m;i++) { u=find(bian[i].start); v=find(bian[i].to); if(u==v) continue;//判断在不在同一个并查集里面，在就下一个循环 ans+=bian[i].val;//不在，就加上 f[u]=v;//连接两个并查集 total++; if(total==n-1) break;//当形成了最小生成树后，退出（之后做的也没用了） } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) f[i]=i; for(i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;bian[i].start,&amp;bian[i].to,&amp;bian[i].val); } sort(bian+1,bian+m+1,cmp);//快排边长 kruskal(); printf(&quot;%d&quot;,ans); return 0; } 二叉堆是一种基础数据结构，主要应用于求出一组数据中的最大最小值。C++ 的STL中的优先队列就是使用二叉堆。不过初赛经常考二叉堆的原理。 事实上支持的操作也是挺有限的（相对于其他数据结构而言），也就插入，查询，删除这一类 对了这篇文章中讲到的堆都是二叉堆，而不是斜堆，左偏树，斐波那契堆什么的我都不会啊 更新概要： 无良博主终于想起来要更新辣 upd1:更新5.2.2-对于该子目所阐述的操作“用两个堆来维护一些查询第k小/大的操作”更新了一道例题-该操作对于中位数题目的求解 upd2：更新5.3-利用堆来维护可以“反悔的贪心” continue... 浅析基础数据结构-二叉堆 一.堆的性质 1.堆是一颗完全二叉树 2.堆的顶端一定是“最大”，最小”的，但是要注意一个点，这里的大和小并不是传统意义下的大和小，它是相对于优先级而言的，当然你也可以把优先级定为传统意义下的大小，但一定要牢记这一点，初学者容易把堆的“大小”直接定义为传统意义下的大小，某些题就不是按数字的大小为优先级来进行堆的操作的 （但是为了讲解方便，下文直接把堆的优先级定为传统意义下的大小，所以上面跟没讲有什么区别？） 3.堆一般有两种样子，小根堆和大根堆，分别对应第二个性质中的“堆顶最大”“堆顶最小”，对于大根堆而言，任何一个非根节点，它的优先级都小于堆顶，对于小根堆而言，任何一个非根节点，它的优先级都大于堆顶（这里的根就是堆顶啦qwq） 来一张图了解一下堆（这里是小根堆）（原谅我丑陋无比的图） 不难看出，对于堆的每个子树，它同样也是一个堆（因为是完全二叉树嘛） 二.堆的操作 1.插入 假设你已经有一个堆了，就是上面那个 这个时候你如果想要给它加入一个节点怎么办，比如说0？ 先插到堆底（严格意义上来说其实0是在5的左儿子的，图没画好放不下去，不过也不影响） 然后你会发现它比它的父亲小啊，那怎么办？不符合小根堆的性质了啊，那就交换一下他们的位置 交换之后还是发现不符合小根堆的性质，那么再换 还是不行，再换 好了，这下就符合小根堆的性质了，是不是顺眼很多了？（假的，图越来越丑，原谅我不想再画） 事实上堆的插入就是把新的元素放到堆底，然后检查它是否符合堆的性质，如果符合就丢在那里了，如果不符合，那就和它的父亲交换一下，一直交换交换交换，直到符合堆的性质，那么就插入完成了 Code： void swap(int &amp;x,int &amp;y){int t=x;x=y;y=t;}//交换函数 int heap[N];//定义一个数组来存堆 int siz;//堆的大小 void push(int x){//要插入的数 heap[++siz]=x; now=siz; //插入到堆底 while(now){//还没到根节点，还能交换 ll nxt=now&gt;&gt;1;//找到它的父亲 if(heap[nxt]&gt;heap[now])swap(heap[nxt],heap[now]);//父亲比它大，那就交换 else break;//如果比它父亲小，那就代表着插入完成了 now=nxt;//交换 } return; } 2.删除 把0插入完以后，忽然你看这个0不爽了，本来都是正整数，怎么就混进来你这个0？ 于是这时候你就想把它删除掉 怎么删除？在删除的过程中还是要维护小根堆的性质 如果你直接删掉了，那就没有堆顶了，这个堆就直接乱了，所以我们要保证删除后这一整个堆还是个完好的小根堆 首先在它的两个儿子里面，找一个比较小的，和它交换一下，但是还是没法删除，因为下方还有节点，那就继续交换 还是不行，再换 再换 好了，这个碍眼的东西终于的下面终于没有节点了，这时候直接把它扔掉就好了 这样我们就完成了删除操作，但是在实际的代码操作中，并不是这样进行删除操作的，有一定的微调，代码中是直接把堆顶和堆底交换一下，然后把交换后的堆顶不断与它的子节点交换，直到这个堆重新符合堆性质~~（但是上面的方式好理解啊）~~ 手写堆的删除支持任意一个节点的删除，不过STL只支持堆顶删除，STL的我们后面再讲 Code： void pop(){ swap(heap[siz],heap[1]);siz--;//交换堆顶和堆底，然后直接弹掉堆底 int now=1; while((now&lt;&lt;1)&lt;=siz){//对该节点进行向下交换的操作 int nxt=now&lt;&lt;1;//找出当前节点的左儿子 if(nxt+1&lt;=siz&amp;&amp;heap[nxt+1]&lt;heap[nxt])nxt++;//看看是要左儿子还是右儿子跟它换 if(heap[nxt]&lt;heap[now])swap(heap[now],heap[nxt]);//如果不符合堆性质就换 else break;//否则就完成了 now=nxt;//往下一层继续向下交换 } } 3.查询 因为我们一直维护着这个堆使它满足堆性质，而堆最简单的查询就是查询优先级最低/最高的元素，对于我们维护的这个堆heap，它的优先级最低/最高的元素就是堆顶，所以查询之后输出heap[1]就好了 一般的题目里面查询操作是和删除操作捆绑的，查询完后顺便就删掉了，这个主要因题而异 三.堆的STL实现 这年头真的没几个人写手写堆~~（可能有情怀党？）~~ 一是手写堆容易写错代码又多，二是STL 直接给我们提供了一个实现堆的简单方式：优先队列 手写堆和STL的优先队列有什么 区别？没有区别 速度方面，手写堆会偏快一点，但是如果开了O2优化优先队列可能会更快； 代码实现难度方面：优先队列完爆手写堆 这两方面综合起来，一般都是用STL的优先队列来实现堆，省选开O2啊 至于为什么前面讲堆的操作时用手写堆，好理解嘛，最好先根据上面的代码和图理解一下堆是怎么实现那些操作的，再来看一下下面的STL的操作 定义一个优先队列： 首先你需要一个头文件：#include&lt;queue&gt; priority_queue&lt;int&gt; q;//这是一个大根堆q priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;//这是一个小根堆q //注意某些编译器在定义一个小根堆的时候greater&lt;int&gt;和后面的&gt;要隔一个空格，不然会被编译器识别成位运算符号&gt;&gt; 优先队列的操作： q.top()//取得堆顶元素，并不会弹出 q.pop()//弹出堆顶元素 q.push()//往堆里面插入一个元素 q.empty()//查询堆是否为空，为空则返回1否则返回0 q.size()//查询堆内元素数量 常用也就这些，貌似还有其他，不过基本也用不到，知道上面那几个也就可以了 不过有个小问题就是STL只支持删除堆顶，而不支持删除其他元素 但是问题不大，开一个数组del，在要删除其他元素的时候直接就标记一下del[i]=1，这里的下标是元素的值，然后在查询的时候碰到这个元素被标记了直接弹出然后继续查询就可以了 （前两天刚从学长处get这个姿势） 另外因为STL好写，下面堆的应用全部都会采用STL的代码实现~~（懒啊，如果有放代码的话）~~ 这里补一下重载运算符在STL的优先队列中应用到的知识 重载运算符是什么？ 把一种运算符变成另外一种运算符（注意，都必须是原有的运算符），比如把&lt;号重载成&gt;号，这个东西学过STL中的sort的同学应该会比较熟悉 这个在优先队列中有什么用处呢？ 之前我们就讲到了，大根堆，小根堆的“大”和“小”都不是传统意义下的“大”和“小”，重载运算符在STL的优先队列中就是用来解决这种“非传统意义的‘大’和‘小’”的 现在你有一个数列，它有权值和优先级两种属性，权值即该数的大小，优先级是给定的，现在要你按照优先级的大小从小到大输出这个数列 这不是Treap吗？这不是sort吗？ 以上两个东西都可以用来实现这道题（逃，而且就实用性而言，sort用来解决这道题是最方便的，但是我们现在要讲的做法是使用堆排序的方式来解决这道题（堆排序是什么？下文堆的应用中有提到） 首先应该想得到结构体，我们定义一个结构体 struct node{ int val,rnd; }a[100]; 但是使用传统做法是行不通的，在小根堆中是通过比较数的大小来确定各个元素在堆中的位置的，但是对于这个a数组，你是要对比权值val的值，还是要对比优先级rnd的值？ 这时候重载运算符就派上用场了 我们在结构体里面再加3行东西 struct node{ int val,rnd; bool operator &lt; (const node&amp;x) const { return rnd&lt;x.rnd; } }a[100]; 这个玩意为什么要这么写呢？ 首先这个玩意是bool类型的，因为你只需要判断这两个是大，还是小；然后，要重载运算符就必须加一个operator这个玩意，不然计算机怎么知道你要干嘛？后面接一个你要重载的运算符，这里是“&lt;”，再后面的括号里面的东西则是你要比较的数据类型，这里是数据类型为node，并且加了一个指针&amp;，将对这个x的修改同步到你实际上要修改的数据那里。然后就是记得加那两个const 然后两个大括号里面就是你重载的内容了，这里是把比较数的大小的小于号，重载成比较node这个数据类型里面的优先级的大小 这个玩意讲的比较多，主要是因为是一个很难懂的东西~~（对我来说？反正当时学的时候就是感觉很晦涩难懂，这里就尽量写详细一点，给和当初的我一样的萌新看一下）~~ 而且在实际中，这个东西的用处也很大，就说在堆里面的应用，在NOIP提高，省选的那个级别，就绝对不可能考裸的堆的，往往你要比较的东西就不是数的大小了，而是按照题目要求灵活更改，这时候重载运算符就帮得上很大忙了 这也就是为什么我在前面反复强调，堆里面的大小，并非传统意义下的大小 四.堆的复杂度 因为堆是一棵完全二叉树，所以对于一个节点数为n的堆，它的高度不会超过log2n 所以对于插入，删除操作复杂度为O(log2n) 查询堆顶操作的复杂度为O(1) 五.堆的应用 1.堆排序 其实就是用要排序的元素建一个堆（视情况而定是大根堆还是小根堆），然后依次弹出堆顶元素，最后得到的就是排序后的结果了 但是裸的并没有什么用，我们有sort而且sort还比堆排快，所以堆排一般都没有这种模板题，一般是利用堆排的思想，然后来搞一些奇奇怪怪的操作，第2个应用就有涉及到一点堆排的思想 2.用两个堆来维护一些查询第k小/大的操作 洛谷P1801 黑匣子 利用一个大根堆一个小根堆来维护第k小，并没有强制在线 不强制在线，所以我们直接读入所有元素，枚举询问，因为要询问第k小，所以把前面的第k个元素都放进大根堆里面，然后如果元素数量大于k，就把堆顶弹掉放到小根堆里面，使大根堆的元素严格等于k，这样这次询问的结果就是小根堆的堆顶了（前面k-1小的元素都在大根堆里面了）。记得在完成这次询问后重新把小根堆的堆顶放到大根堆里面就好。 洛谷P1090 合并果子 直接从所有果子中找到最小堆最小的果子，合并之后再放入堆中。 洛谷P1168 中位数 中位数也是这种操作可以解决的一种经典问题，但是实际应用不大（这种操作的复杂度为 O(nlogn)O(nlogn)，然而求解中位数有 O(n)O(n)做法） Luogu中也有此类例题，题解内也讲的比较清楚了，此处不再赘述，读者可当做拓展练习进行食用 提示：设序列长度为 NN，则中位数其实等价于序列中 N/2N/2大的元素 #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ll long long #define inf 1&lt;&lt;30 #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il int max(int x,int y){return x&gt;y?x:y;} il int min(int x,int y){return x&lt;y?x:y;} il int abs(int x){return x&gt;0?x:-x;} il void swap(int &amp;x,int &amp;y){int t=x;x=y;y=t;} il void readl(ll &amp;x){ x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-f;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();} x*=f; } il void read(int &amp;x){ x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-f;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();} x*=f; } using namespace std; /*===================Header Template=====================*/ #define N 200010 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; priority_queue&lt;int&gt; q1; int n,m,a[N],b[N]; int main(){ in2(n,m); for(int i=1;i&lt;=n;i++)in1(a[i]); for(int i=1;i&lt;=m;i++)in1(b[i]); int i=1; for(int j=1;j&lt;=m;j++){ for(;i&lt;=b[j];i++){ q1.push(a[i]); if(q1.size()==j)q.push(q1.top()),q1.pop(); } printf(&quot;%d\\n&quot;,q.top()); q1.push(q.top());q.pop(); } return 0; } 事实上堆在难度较高的题目方面更多的用于维护一些贪心操作，以降低复杂度，很少会有题目是以堆为正解来出的了，更多的，堆在这些题目中处于“工具”的位置 3.利用堆来维护可以“反悔的贪心” 题目：[Luogu P2949 USACO09OPEN]工作调度Work Scheduling 这道题的话算是这种类型应用的经典题了 首先只要有贪心基础就不难想出一个解题思路：因为所有工作的花费时间都一样，我们只要尽量的选获得利润高的工作，以及对于每个所选的工作，我们尽量让它在更靠近它的结束时间的地方再来工作 但是两种条件我们并不好维护，这种两个限制条件的题目也是有一种挺经典的做法的：对一个限制条件进行排序，对于另一个限制条件使用某些数据结构来维护（如treap，线段树，树状数组之类），但是这并不在我们今天的讨论范畴QAQ 考虑怎么将这两个条件“有机统一”。 排序的思路是没有问题的，我们可以对每个工作按照它的结束时间进行排序，从而来维护我们的第二个贪心的想法。 那么对于这样做所带来的一个冲突：对于一个截止时间在d的工作，我们有可能把0~d秒全都安排满了（可能会有多个任务的截止时间相同） 怎么解决这种冲突并保证答案的最有性呢？ 一个直观的想法就是把我们目前已选的工作全部都比较一下，然后选出一个创造的利润最低的工作（假设当前正在决策的这个工作价值很高），然后舍弃掉利润最低的工作，把这个工作放进去原来的那个位置。（因为我们已经按照结束时间排序了，所以舍弃的那个任务的截止完成时间一定在当前决策的工作的之前） 但是对于大小高达 10^6106的n， O(n^2)O(n2)的复杂度显然是无法接受的，结合上面的内容，读者们应该也不难想出，可以使用堆来优化这个操作 我们可以在选用了这个工作之后，将当前工作放入小根堆中，如果堆内元素大于等于当前工作的截止时间了（因为这道题中，一个工作的执行时间是一个单位时间），我们就可以把当前工作跟堆顶工作的价值比较，如果当前工作的价值较大，就可以将堆顶弹出，然后将新的工作放入堆中，给答案加上当前工作减去堆顶元素的价值（因为堆顶元素在放入堆中的时候价值已经累加进入答案了）。如果堆内元素小于截止时间那么直接放入堆中就好 至此，我们已经可以以 O(nlogn)O(nlogn)的效率通过本题 而通过这道题我们也可以发现，只有在优化我们思考出来的贪心操作的时间复杂度时，我们才用到了堆。正如我们先前所说到的，在大部分有一定难度的题目里，堆都是以一个“工具”的身份出现，用于优化算法（大多时候是贪心）的时间复杂度等 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std ; #define N 100010 #define int long long int n , m ; struct node { int d,p ; bool operator &lt; ( const node &amp;x ) const { return p&gt;x.p; } } a[ N ] ; bool cmp( node a , node b ) { return a.d==b.d?a.p&gt;b.p:a.d&lt;b.d; } priority_queue&lt; node &gt; q ; signed main() { scanf( &quot;%lld&quot; , &amp;n ) ; for( int i = 1 ; i &lt;= n ; i ++ ) { scanf( &quot;%lld%lld&quot; , &amp;a[i].d , &amp;a[i].p ) ; } sort(a+1,a+n+1,cmp); int ans = 0 ; for( int i = 1 ; i &lt;= n ; i ++ ) { if( a[i].d&lt;=(int)q.size() ) { if( q.top().p&lt;a[i].p ) { ans += a[i].p-q.top().p ; q.pop() ; q.push(a[i]) ; } } else q.push(a[i]) , ans += a[ i ].p ; } printf( &quot;%lld\\n&quot; , ans ) ; } 字符串学习笔记·哈希（HASH）与字典树（Trie） 一、首先理解字符串操作的意义： 没意义 ~emmmmmmemmmmmmemmmmmm其实字符串操作的意义是很浅显的，比如百度的推荐搜索啊，比如查找比对一篇题解里有多少个相同或者不同的脏字然后 kkksc03kkksc03kkksc03再根据其数量、恶劣程度决定用多大的刀将博主 killkillkill掉。。。所以字符串操作很重要啊喂 qwqqwqqwq。 再来考虑时间：如果百度对于一个人的一次“常搜”推荐需要 10s10s10s，那么对于全国网友来说，同时上网的人群基数很高，那么如果服务器性能不好的话，怕不是要三星 note7note7note7 qwqqwqqwq？？？ 所以啊，打造高效的字符串算法是很有必要滴！ 二、言归正传，浅析字符串哈希 哈希其实是所有字符串操作中，笔者认为最简单的操作了（except输入输出qwq）。哈希的过程，其实可以看作对一个串的单向加密过程，并且需要保证所加的密不能高概率重复（就像不能让隔壁老王轻易地用它家的钥匙打开你家门一样qwq），通过这种方式来替代一些很费时间的操作。 比如，最常见的，当然就是通过哈希数组来判断几个串是否相同（洛谷P3370）。此处的操作呢，很简单，就是对于每个串，我们通过一个固定的转换方式，将相同的串使其的“密”一定相同，不同的串 *尽量* 不同。 此处有人指出：那难道不能先比对字符串长度，然后比对ASCLL码之和吗？事实上显然是不行的（比如ab和ba，并不是同一个串，但是如是做却会让其认为是qwq）。这种情况就叫做 hashhashhash冲突，并且在如此的单向加密哈希中， hashhashhash冲突的情况在所难免（bzoj就有这种让你给出一组样例，使得一段哈希代码冲突的题，读者可以尝试尝试）。 而我们此处介绍的，即是最常见的一种哈希：进制哈希。进制哈希的核心便是给出一个固定进制 basebasebase，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个 basebasebase进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同 奉上 P3370acP3370acP3370ac代码（单哈希）： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; typedef unsigned long long ull; ull base=131; ull a[10010]; char s[10010]; int n,ans=1; int prime=233317; ull mod=212370440130137957ll; ull hashe(char s[]) { int len=strlen(s); ull ans=0; for (int i=0;i&lt;len;i++) ans=(ans*base+(ull)s[i])%mod+prime; return ans; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s); a[i]=hashe(s); } sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) { if(a[i]!=a[i+1]) ans++; } printf(&quot;%d&quot;,ans); } 当然，再好的哈希也会有冲突，此时有两种做法可以解决或者降低哈希冲突的可能性 1、无错哈希 其实原理很简单，就是我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突（比如somebody’s birthday qwq）。 先贴代码： for(int i=1;i&lt;=m;i++)//m个串 { cin&gt;&gt;str;//下一行的check为bool型 while(check[hash(str)])hash[i]+=19260817; hash[i]+= hash(str) ; } 正如下图（亲手做的英文高逼格）： 但是，这种方法类似桶查找，但是桶查找的弊端2就会很恶心——数据过大， checkcheckcheck数组无能为力来支持上亿个空间（弊端1是由于数据具有跳跃性，浪费最后的统计次数，但在此不是特别明显，就当我皮了一下qwq） 2、多重哈希 这其实就是你用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性。 下面皮一个哈希自动机qwq（不用百度了，名字自己起的） //哈希自动机,需要二维hash数组 for伪代码排序，用来使哈希值单调（更好判断相/不同的数量） for(int i=1;i&lt;=m;i++){ check=1； for(int j=1;j&lt;=qwq;j++)//皮一下 if(hash[j][i]==hash[j][i+1]){check=0;break;} if(check)ans++;//此为判断相同个数 } 三、字典树浅析 1、简要介绍 首先要知道，字典树是一种假想数据结构（数据结构不都是 假想的吗qwq），那么问题来了——为什么是要用字典树呢？为什么不用类似字典链表之类的东西呢？很简单，所有树形结构 都有一个基本特点，就是 元素与元素间的关系为继承的一对多关系。 拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行 比如下图就是一棵 TrieTrieTrie，这里用颜色区分单词路径上的点 2、字典树基础与如何建树（插入操作） 首先，关于字典树，我们一般不是用点来存储字符的，而是用边——为什么呢？之后再说（十分皮地卖个关子qwq）。 重新首先，一般来说，字典树是不会使用根节点的，原因很浅显，因为根节点的个数决定究竟有几棵字典树，而通常字典树是只有一棵的，否则产生森林会很麻烦（qwq你皮你就splay，并且如果有森林的话应该叫做“字典森林”啊喂）。 但是我们要知道，并不是一个题中所有的串都有公共前缀（肯定不会的吧qwq），可如果根节点唯一，就代表他们一定有公共前缀，并且公共前缀的长度必定大于等于1。 其次，字典树中每个节点的子节点数量都肯定会小于某个数。 如果字典树里都是小写字母，那么“某个数”就是26；如果大小写都有，“某个数”就应该是52（证明过程：显然）； 并且每个节点的所有的边都不同，这条性质可以便于我们判断在某一棵字典树到底有没有某条链：只要前缀不符合，就不需要再判断，因为必然没有（同一深度、同一父亲，边与边必定互异） 在这里，我选择用结构体来存树，具体解释见注释： //建树（其实就是存点啦） struct nodes{ int son[26]; //此处只考虑小写字母字典树 bool mark; // 此为标记，作用下面说 }trie[10001]; int root=0,num=0; //根节点永久为0 qwq bool insert_check(char *str) { int position=root;//初始化位置,跟深度没有直接关系 for(int i=0;str[i];i++) { int symbol=(int)str[i]-'a'; /*此处实际是因为我们的trie都是存int的,如果贸然存char会 很别扭qwq，并且此处由于都是小写字母，所以 -‘a’ ,如果 存了别的类型的字符，需要特判，保证字符容易确定 */ if(!trie[position].son[symbol]) //还没有被编号 trie[position].son[symbol]=++num;//编一个号 position=trie[position].son[symbol] ; //更新迭代位置，直到字符链的最末端 } int temp=trie[position].mark; trie[position].mark =1; //将这条链的最末端置为1，如果还有重复的串，那么一定会出现 //最末端相同 ;反之，最末端节点的mark相同也可以推出链相同， //借此来判断串是否相同 return temp!=0; /*最后说一下为什么要编号：我们根据程序可以看出，字符串是 按秩插入树，所以一条链上的编号肯定满足单调，便于我们查找 和比对*/ } 于是便可以通过这种方式比对字符串，期望时间复杂度O（n）大多用于比对。 3、关于字典树的查找 查找前缀比较好写，只需要一边判断是否符合要求，一边判断是否继续迭代即可。 int root=0; bool find(char* str) { int pos=root; for(int i=0;str[i];i++) { int x=str[i]-'a'; if(trie[pos].son[x]==0)return false; //如果在建完树之后这个点还没有被编号， //那么就肯定不存在这条链。（互异性） pos=trie[pos].son[x] ;//继续迭代 } return true; } 其实查询单词和查询前缀差别不大，只是我们每次都需要维护一个 check[i]check[i]check[i]（ boolboolbool），存在单词链的末尾。 每当一个新字符已经被标记时（即所查询单词的这个字母及其前缀都在树的某条链上），我们使这个字符 checkcheckcheck异于它祖先们的 checkcheckcheck，最后判断**该条匹配链结尾字符的 checkcheckcheck是否异于链上其他字符的 checkcheckcheck**即可判断是否有这个单词（如果没有的话，末尾的 checkcheckcheck肯定与链上其他的相同啊qwq） 至于前缀出现次数，很简单，只要将每一个前缀的出现次数存到它相连的子节点，最后输出前缀最后一个字符所带的次数即可（可以用数组维护，也可以直接写在结构体里） 好啦，就是这样，希望对大家有所帮助 字符串学习笔记 · 浅析KMP——单模式串匹配算法 upd:upd:upd:锅已补 一、何谓模式串匹配 模式串匹配，就是给定一个需要处理的文本串（理论上应该很长）和一个需要在文本串中搜索的模式串（理论上长度应该远小于文本串），查询在该文本串中，给出的模式串的出现有无、次数、位置等。 模式串匹配的意义在于，如果我是一个平台的管理员，我可以针对一篇文章或者一句话，搜索其中某个特定脏字或者不雅词汇的出现次数、位置——次数可以帮助我决定采取何种等级对于该用户的惩罚方式，而位置则可以帮助我给每一个脏词打上“*”的标记来自动屏蔽这些脏词。 二、浅析 KMPKMPKMP 之思想 哦呵呵这个算法的名字比较诡异是因为有三位伟大的科学家共同设计完成……分别是 Knuth(D.E.Knuth)&amp;Morris(J.H.Morris)&amp;Pratt(V.R.Pratt)\\mathcal{Knuth(D.E.Knuth) \\&amp; Morris(J.H.Morris)\\&amp; Pratt(V.R.Pratt)}Knuth(D.E.Knuth)&amp;Morris(J.H.Morris)&amp;Pratt(V.R.Pratt) 然而我并不知道他们是谁 首先要理解，朴素的单模式串匹配大概就是枚举每一个文本串元素，然后从这一位开始不断向后比较，每次比较失败之后都要从头开始重新比对，大概期望时间复杂度在 Θ(n+m)\\Theta(n+m)Θ(n+m) 左右，对于一般的弱数据还是阔以跑的了滴。但是其实是可以被卡成 O(nm)O(nm)O(nm)的。 emmmmemmmmemmmm并且还是比较容易卡的。 而 KMPKMPKMP 的精髓在于，对于每次失配之后，我都不会从头重新开始枚举，而是根据我已经得知的数据，从某个特定的位置开始匹配；而对于模式串的每一位，都有唯一的“特定变化位置”，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间。 比如我们考虑一组样例： 模式串：abcab 文本串：abcacababcab 首先，前四位按位匹配成功，遇到第五位不同，而这时，我们选择将 abcababcababcab向右移三位，或者可以直接理解为移动到模式串中与失配字符相同的那一位。可以简单地理解为，我们将两个已经遍历过的模式串字符重合，导致我们可以不用一位一位地移动，而是根据相同的字符来实现快速移动。 模式串： abcab 文本串：abcacababcab 但有时不光只会有单个字符重复： 模式串：abcabc 文本串：abcabdababcabc 当我们发现在第六位失配时，我们可以将模式串的第一二位移动到第四五位，因为它们相同 qwqqwqqwq . 模式串： abcabc 文本串：abcabdababcabc 那么现在已经很明了了， KMPKMPKMP 的重头戏就在于用失配数组来确定当某一位失配时，我们可以将前一位跳跃到之前匹配过的某一位。而此处有几个先决条件需要理解： 1、我们的失配数组应当建立在模式串意义下，而不是文本串意义下。因为显然模式串要更加灵活，在失配后换位时，更灵活简便地处理。 2、如何确定位置呢？ 首先我们要明白，基于先决条件 111而言，我们在预处理时应当考虑当模式串的第 iii 位失配时，应当跳转到哪里.因为在文本串中，之前匹配过的所有字符已经没有用了——都是匹配完成或者已经失配的，所以我们的 kmpkmpkmp 数组（即是用于确定失配后变化位置的数组，下同）应当记录的是： 在模式串 str1str1str1 中，对于每一位 str1(i)str1(i)str1(i) ,它的 kmpkmpkmp 数组应当是记录一个位置 jjj, j≤ij \\leq ij≤i 并且满足 str1(i)=str1(j)str1(i)=str1(j)str1(i)=str1(j) 并且在 j!=1j!=1j!=1 时理应满足 str1(1)str1(1)str1(1)至 str1(j−1)str1(j-1)str1(j−1) 分别与 str(i−j+1)str(i-j+1)str(i−j+1)~ str1(i−1)str1(i-1)str1(i−1) 按位相等 上述即为移位法则 3、从前缀后缀来解释 KMPKMPKMP : 首先解释前后缀(因为太简单就不解释了 qwqqwqqwq )： 给定串：ABCABA 前缀：A,AB,ABC,ABCA,ABCAB,ABCABA 后缀：A,BA,ABA,CABA,BCABA,ABCABA 其实刚才的移位法则就是对于模式串的每个前缀而言，用 kmpkmpkmp 数组记录到它为止的模式串前缀的真前缀和真后缀最大相同的位置（注意，这个地方没有写错，是真的有嵌套 qwqqwqqwq ）。然而这个地方我们要考虑“模式串前缀的前缀和后缀最大相同的位置”原因在于，我们需要用到 kmpkmpkmp 数组换位时，当且仅当未完全匹配。所以我们的操作只是针对模式串的前缀 −−--−−毕竟是失配函数，失配之后只有可能是某个部分前缀需要“快速移动”。所以这就可以解释 KMPKMPKMP 中前后缀应用的一个特点： KMPKMPKMP 中前后缀不包括模式串本身,即只考虑真前缀和真后缀,因为模式串本身需要整体考虑，当且仅当匹配完整个串之后；而匹配完整个串不就完成匹配了吗 qwqqwqqwq 三、代码实现 1、 kmp[i]kmp[i]kmp[i] 用于记录当匹配到模式串的第 iii 位之后失配,该跳转到模式串的哪个位置，那么对于模式串的第一位和第二位而言，只能回跳到 111，因为是 KMPKMPKMP 是要将真前缀跳跃到与它相同的真后缀上去（通常也可以反着理解），所以当 i=0i=0i=0 或者 i=1i=1i=1 时,相同的真前缀只会是 str1(0)str1(0)str1(0) 这一个字符，所以 kmp[0]=kmp[1]=1kmp[0]=kmp[1]=1kmp[0]=kmp[1]=1。 2、对于如何和文本串比对，很简单： int j; j=0;//j可以看做表示当前已经匹配完的模式串的最后一位的位置 //如果楼上看不懂，你也可以理解为j表示模式串匹配到第几位了 for(int i=1;i&lt;=la;i++) { while(j&amp;&amp;b[j+1]!=a[i])j=kmp[j]; //如果失配 ，那么就不断向回跳，直到可以继续匹配 if (b[j+1]==a[i]) j++; //如果匹配成功，那么对应的模式串位置++ if (j==lb) { cout&lt;&lt;i-lb+1&lt;&lt;endl; j=kmp[j]; //继续匹配 } } 3、那么我们该如何处理 kmpkmpkmp 数组呢？我们可以考虑用模式串自己匹配自己 j=0; for (int i=2;i&lt;=lb;i++) { while(j&amp;&amp;b[i]!=b[j+1]) //此处判断j是否为0的原因在于，如果回跳到第一个字符就不 用再回跳了 j=kmp[j]; //通过自己匹配自己来得出每一个点的kmp值 if(b[j+1]==b[i])j++; kmp[i]=j; //i+1失配后应该如何跳 } 那么这个“自己匹配自己”该如何理解呢？我们可以这么想： 首先，在单次循环只有一个 ififif 来判断的原因在于每次至多向后多求一位的 nextnextnext； 并且 jjj 是拥有可继承性的，由于 jjj 是用于比对前缀后缀的，那么对于一组前后缀而言，第 i−1i-1i−1 和第 j−1j-1j−1 位之前均相同或者有不同，决定着 iii 和 jjj 匹配的结果是从 000 开始还是基于上一个 jjj 继续 ++++++ 贴标程： #include&lt;iostream&gt; #include&lt;cstring&gt; #define MAXN 1000010 using namespace std; int kmp[MAXN]; int la,lb,j; char a[MAXN],b[MAXN]; int main() { cin&gt;&gt;a+1; cin&gt;&gt;b+1; la=strlen(a+1); lb=strlen(b+1); for (int i=2;i&lt;=lb;i++) { while(j&amp;&amp;b[i]!=b[j+1]) j=kmp[j]; if(b[j+1]==b[i])j++; kmp[i]=j; } j=0; for(int i=1;i&lt;=la;i++) { while(j&gt;0&amp;&amp;b[j+1]!=a[i]) j=kmp[j]; if (b[j+1]==a[i]) j++; if (j==lb) {cout&lt;&lt;i-lb+1&lt;&lt;endl;j=kmp[j];} } for (int i=1;i&lt;=lb;i++) cout&lt;&lt;kmp[i]&lt;&lt;&quot; &quot;; return 0; } 那么时间复杂度为 Θ(m+n)\\Theta(m+n)Θ(m+n) ,比朴素算法有了极大的优化。 Extra KnowledgeExtra \\ \\ KnowledgeExtra Knowledge浅析复杂度证明 题外话：本来想扯摊还分析来着，但是 rqyrqyrqy说的好像比较直接易懂，于是在这里就引用了 rqyrqyrqy的话： 每次位置指针 i++i++i++时，失配指针 jjj至多增加一次，所以 jjj至多增加 lenlenlen次，从而至多减少 lenlenlen次，所以就是 Θ(lenN+lenM)=Θ(N+M)\\Theta(len_N + len_M) = \\Theta(N + M)Θ(lenN​+lenM​)=Θ(N+M)的 总之很迷就对了（逃 其实我们也可以发现， KMPKMPKMP 算法之所以快，不仅仅由于它的失配处理方案，更重要的是利用前缀后缀的特性，从不会反反复复地找，我们可以看到代码里对于匹配只有一重循环，也就是说 KMPKMPKMP 算法具有一种“最优历史处理”的性质，而这种性质也是基于 KMPKMPKMP 的核心思想的。 题解 P3379 【【模板】最近公共祖先（LCA）】 LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科 例如： 在这棵树中 171717 和 888 的LCA就是 333， 999 和 777 的LCA就是 777 。 明白了LCA后，就下来我们就要探讨探讨LCA怎么求了 qwqqwqqwq 暴力算法 以 171717 和 181818 为例，既然要求LCA，那么我们就让他们一个一个向上爬~~(我要一步一步往上爬 —— 《蜗牛》)~~，直到相遇为止。第一次相遇即是他们的LCA。 模拟一下就是： 17−&gt;14−&gt;10−&gt;7−&gt;317-&gt;14-&gt;10-&gt;7-&gt;317−&gt;14−&gt;10−&gt;7−&gt;3 18−&gt;16−&gt;12−&gt;8−&gt;5−&gt;318-&gt;16-&gt;12-&gt;8-&gt;5-&gt;318−&gt;16−&gt;12−&gt;8−&gt;5−&gt;3 最终结果就是 333 当然这个算法妥妥的会T飞掉，那么我们就要进行优化，于是就有了用倍增来加速的倍增LCA，这也是我们今天介绍的重点。 倍增算法 所谓倍增，就是按 222的倍数来增大，也就是跳 1,2,4,8,16,321,2,4,8,16,321,2,4,8,16,32 …… 不过在这我们不是按从小到大跳，而是从大向小跳，即按…… 32,16,8,4,2,132,16,8,4,2,132,16,8,4,2,1来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 555 为例，从小向大跳， 5≠1+2+45≠1+2+45​=1+2+4,所以我们还要回溯一步，然后才能得出 5=1+45=1+45=1+4；而从大向小跳，直接可以得出 $5=4+$1。这也可以拿二进制为例， 5(101)5(101)5(101)，从高位向低位填很简单，如果填了这位之后比原数大了，那我就不填，这个过程是很好操作的。 还是以 171717 和 181818 为例，如果分别从 171717和 181818跳到 333的话，它们的路径分别是*（此例只演示倍增，并不是倍增LCA算法的真正路径）*： 17−&gt;317-&gt;317−&gt;3 18−&gt;5−&gt;318-&gt;5-&gt;318−&gt;5−&gt;3 可以看出向上跳的次数大大减小。这个算法的时间复杂度为 O(nlogn)O(nlogn)O(nlogn),已经可以满足大部分的需求。 想要实现这个算法，首先我们要记录各个点的深度和他们 2i2^i2i级的的祖先，用数组 depth\\rm{depth}depth表示每个节点的深度， fa[i][j]fa[i][j]fa[i][j]表示节点 iii的 2j2^j2j级祖先。 代码如下： void dfs(int now, int fath) { //now表示当前节点，fath表示它的父亲节点 fa[now][0] = fath; depth[now] = depth[fath] + 1; for(int i = 1; i &lt;= lg[depth[now]]; ++i) fa[now][i] = fa[fa[now][i-1]][i-1]; //这个转移可以说是算法的核心之一 //意思是now的2^i祖先等于now的2^(i-1)祖先的2^(i-1)祖先 //2^i = 2^(i-1) + 2^(i-1) for(int i = head[now]; i; i = e[i].nex) if(e[i].t != fath) dfs(e[i].t, now); } 预处理完毕后，我们就可以去找它的LCA了，为了让它跑得快一些，我们可以加一个常数优化(来自洛谷提高组讲义) for(int i = 1; i &lt;= n; ++i) //预先算出log_2(i)+1的值，用的时候直接调用就可以了 lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); //看不懂的可以手推一下 接下来就是倍增LCA了，我们先把两个点提到同一高度，再统一开始跳。 但我们在跳的时候不能直接跳到它们的LCA，因为这可能会误判，比如 444和 888，在跳的时候，我们可能会认为 111是它们的LCA，但 111只是它们的祖先，它们的LCA其实是 333。所以我们要跳到它们LCA的下面一层，比如 444和 888，我们就跳到 444和 555，然后输出它们的父节点，这样就不会误判了。 int LCA(int x, int y) { if(depth[x] &lt; depth[y]) //用数学语言来说就是：不妨设x的深度 &gt;= y的深度 swap(x, y); while(depth[x] &gt; depth[y]) x = fa[x][lg[depth[x]-depth[y]] - 1]; //先跳到同一深度 if(x == y) //如果x是y的祖先，那他们的LCA肯定就是x了 return x; for(int k = lg[depth[x]] - 1; k &gt;= 0; --k) //不断向上跳（lg就是之前说的常数优化） if(fa[x][k] != fa[y][k]) //因为我们要跳到它们LCA的下面一层，所以它们肯定不相等，如果不相等就跳过去。 x = fa[x][k], y = fa[y][k]; return fa[x][0]; //返回父节点 } 完整的求 171717和 181818的LCA的路径： 17−&gt;10−&gt;7−&gt;317-&gt;10-&gt;7-&gt;317−&gt;10−&gt;7−&gt;3 18−&gt;16−&gt;8−&gt;5−&gt;318-&gt;16-&gt;8-&gt;5-&gt;318−&gt;16−&gt;8−&gt;5−&gt;3 解释：首先， 181818要跳到和 171717深度相同，然后 181818和 171717一起向上跳，一直跳到LCA的下一层( 171717是 777， 181818是 555)，此时LCA就是它们的父亲 总体来说就是这样了，也不知道我这个蒟蒻讲的各位 dalaodalaodalao能不能看明白 orz\\tt{orz}orz 完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; struct zzz { int t, nex; }e[500010 &lt;&lt; 1]; int head[500010], tot; void add(int x, int y) { e[++tot].t = y; e[tot].nex = head[x]; head[x] = tot; } int depth[500001], fa[500001][22], lg[500001]; void dfs(int now, int fath) { fa[now][0] = fath; depth[now] = depth[fath] + 1; for(int i = 1; i &lt;= lg[depth[now]]; ++i) fa[now][i] = fa[fa[now][i-1]][i-1]; for(int i = head[now]; i; i = e[i].nex) if(e[i].t != fath) dfs(e[i].t, now); } int LCA(int x, int y) { if(depth[x] &lt; depth[y]) swap(x, y); while(depth[x] &gt; depth[y]) x = fa[x][lg[depth[x]-depth[y]] - 1]; if(x == y) return x; for(int k = lg[depth[x]] - 1; k &gt;= 0; --k) if(fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k]; return fa[x][0]; } int main() { int n, m, s; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s); for(int i = 1; i &lt;= n-1; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); add(y, x); } for(int i = 1; i &lt;= n; ++i) lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); dfs(s, 0); for(int i = 1; i &lt;= m; ++i) { int x, y; scanf(&quot;%d%d&quot;,&amp;x, &amp;y); printf(&quot;%d\\n&quot;, LCA(x, y)); } return 0; } 题解 P5788 【【模板】单调栈】 posted on 2019-12-17 13:17:56 | under 模板 | update：2019/12/13 $\\ \\ \\ \\ \\ \\ \\ $觉得写得有点不清楚，稍微改了一下语言以及添加一道例题。 update：2020/2/17 $\\ \\ \\ \\ \\ \\ \\ $修改了一点错别字，改了一下内容和定义。造成的曲解抱歉了。修改了伪代码使其规范。修改了题解规范。 单调栈 前言 $\\ \\ \\ \\ \\ \\ \\ $也是晚上突然看到新增加的模板。想着没学多久，想来发篇博客，熟悉一下。 感谢 lucky52529的博客 定义 $\\ \\ \\ \\ \\ \\ \\ $我们都知道单调队列，也就是在这个队列里面存放的数据应该是有序的。当然，单调栈从这个冷艳的名字就可以看出来，这个栈存放的数据内部对应的顺序也应该是有序的。 $\\ \\ \\ \\ \\ \\ \\ $我们根据存放下标对应元素的顺序，可以分为两种单调栈： 单调递减栈，指的就是栈内存放下标对应元素构成的序列对应的元素单调递减。 单调递增栈，指的就是栈内存放下标对应元素构成的序列对应的元素单调递增。 $\\ \\ \\ \\ \\ \\ \\ $一定注意，我们存放的一般是下标，而不是元素。但是作为比较的标准是下标对应的元素。 模拟 $\\ \\ \\ \\ \\ \\ \\ $让我们模拟一遍单调栈的运行过程，这里的单调栈是单调递增栈。 $\\ \\ \\ \\ \\ \\ \\ $我们现在有 666 个数 5,2,3,4,1,65,2,3,4,1,65,2,3,4,1,6。 $\\ \\ \\ \\ \\ \\ \\ $首先我们要明白，我们存放的是下标。然后，我们直接把元素放在栈顶，会破坏它的单调性。所以我们需要吐出栈顶的元素，使得我们当前的元素再加进去不会破坏它的单调性。 我们当前栈内没有元素，将 555 加入。现在栈内元素应该是 111。 当前元素为 222，我们发现加入之后不能单调，于是吐出 555，加入 222。当前栈内元素为 222。 接下来是 3,43,43,4。我们发现加入不会破坏单调性，于是直接加入，栈内元素 2,3,42,3,42,3,4。 遇到 111，只能吐出栈内所有元素，加入 111。 最后加入 666。整个算法流程完成。 伪代码 $\\ \\ \\ \\ \\ \\ \\ $我们可以根据这个算法流程，打出伪代码。 stack&lt;int&gt; S; for i←1 to n if S.size=0 || a[S.top]&gt;=a[i] then S.push i else while S.size &amp;&amp; a[S.top]&lt;a[i] do S.pop end S.push i $\\ \\ \\ \\ \\ \\ \\ $我猜是这样，毕竟没学过伪代码。 杂七杂八的问题 $\\ \\ \\ \\ \\ \\ \\ $对于我自己来说，我学的时候会有一些问题，在这里带着自己的经验解释一下。 单调栈解决的主要问题是什么呢？ $\\ \\ \\ \\ \\ \\ \\ $就跟单调队列差不多。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。相比较，实际上单调栈用的虽然少一些，但是比单调队列更加灵活多变。 为什么单调栈是正确的呢？ $\\ \\ \\ \\ \\ \\ \\ $对于这道题来说，我们定义一个元素失效，当且仅当这个元素的 fif_ifi​ 被保存。我们假设将栈中已有元素。既然栈中元素没有被弹出，那么证明还没有遇到比它大的元素。当我们的元素从栈中弹出的时候，这证明了它发现了第一个比它还要大的数，这道题刚好满足，于是保存 fif_ifi​ ，继续算法流程。同理，对于之前的主要问题，我们找到了一个比它还要大的数，说明这个区间结束了。 单调栈的时间复杂度是？ $\\ \\ \\ \\ \\ \\ \\ $想一下，我们的每一个元素最多进栈/出栈一次，所以说时间复杂度 O(n)O(n)O(n)。 $\\ \\ \\ \\ \\ \\ \\ $下文所说元素可能不是指的下标对应元素而是直接指元素，没有提示请不要混淆。 结束标识符 $\\ \\ \\ \\ \\ \\ \\ $对于某些特殊题目，栈内元素出不完，会导致答案错误，这时候我们要添加结束标识符强制吐出所有栈内元素。 $\\ \\ \\ \\ \\ \\ \\ $找个例子： 视野总和 $\\ \\ \\ \\ \\ \\ \\ $lucky52529的博客，自查第一题。 $\\ \\ \\ \\ \\ \\ \\ $我们很容易想到构造一个单调递增栈，如果遇到大于栈顶的元素，开始更新之前不高于当前人所能看到的值即可。 $\\ \\ \\ \\ \\ \\ \\ $但是我们发现我们 WA 了，因为遗留在栈里面的人还没有计算贡献。我们于是用结束标识符，这里是极大值，想象一个无限高的人站在最右边，那么我们所有人都能出栈，不会漏掉。 代码 #include&lt;cstdio&gt; #include&lt;stack&gt; #include&lt;algorithm&gt; #define mp make_pair using namespace std; stack&lt;long long&gt; S; long long a[5000005],ans; int main(){ long long n; scanf(&quot;%lld&quot;,&amp;n); for(long long i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;a[i]); a[n+1]=10086001100860011ll;//结束标识符 for(long long i=1;i&lt;=n+1;++i) { if(S.empty() || a[S.top()]&gt;=a[i]) S.push(i); else { while(S.size() &amp;&amp; a[S.top()]&lt;a[i]) { long long Top=S.top(); ans+=(i-Top-1); S.pop(); } S.push(i); } } printf(&quot;%lld&quot;,ans); return 0; } 直方图中最大的矩形 $\\ \\ \\ \\ \\ \\ \\ $lucky52529的博客，自查第二题。 $\\ \\ \\ \\ \\ \\ \\ $上面都是用的单调递增栈，这次我们用单调递减栈。我们每次将元素从栈里面弹出的时候，因为我们的答案可能会出现在里面，所以我们弹出元素就计算一遍答案。 代码 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;queue&gt; using namespace std; long long a[100005],n; stack&lt;long long&gt; S; void debug() { stack&lt;long long&gt; tmp=S; while(tmp.size()) printf(&quot;%lld &quot;,tmp.top()),tmp.pop(); puts(&quot;&quot;); } void Clear() { stack&lt;long long&gt; tmp; S=tmp; } int main(){ while(scanf(&quot;%lld&quot;,&amp;n) &amp;&amp; n) { Clear(); long long ans=0; for(long long i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;a[i]); a[n+1]=-2147483647; for(long long i=1;i&lt;=n+1;++i) { if(S.empty() || a[S.top()]&lt;=a[i]) S.push(i); else { long long Top=0; while(S.size() &amp;&amp; a[S.top()]&gt;a[i]) { // debug(); Top=S.top(); ans=max(ans,(i-Top)*a[Top]); S.pop(); } a[Top]=a[i];//why? S.push(Top); } } printf(&quot;%lld\\n&quot;,ans); } return 0; } $\\ \\ \\ \\ \\ \\ \\ $发现我在 a[Top]=a[i]; 这个语句后打了个 //why?。这是为什么呢？ $\\ \\ \\ \\ \\ \\ \\ $我们弹出元素计算答案，相信大家都能够理解。但是为什么要更改我们的 aaa 数组呢？ $\\ \\ \\ \\ \\ \\ \\ $举个例子： 2,3,12,3,12,3,1。 $\\ \\ \\ \\ \\ \\ \\ $思考一下，我们要维持它单调，假设加入 333 这个元素的时候栈只有它一个元素。我们的 toptoptop 会从 111 变成 333。但是 1,21,21,2 两个元素对应的值都比它大。但是我们为了保持栈中的递增属性，并且可以让向左拓展，我们索性修改了 iii 的下标，将他修改为最左边的 toptoptop 下标，所以当我们下次需要以他为基准获取矩形面积。 题解 $\\ \\ \\ \\ \\ \\ \\ $对于这道题，我们构造一个单调递增栈，我们可以想象，我们每次出栈，都是因为找到了一个比当前栈顶元素大的元素，可以证明它一定是最早出现的，于是用数组记录答案，每次出栈保存答案。注意卡常。 #include&lt;cstdio&gt; int a[3000005],f[3000005],S[3000005],n; int read() { int x=0,f=1; char c=getchar(); while(c&lt;'0' || c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' &amp;&amp; c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^'0'),c=getchar(); return x*f; } void write(int x) { if(x&lt;0) putchar('-'),x=-x; if(x&gt;9) write(x/10); putchar(x%10+'0'); } int main(){ n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); int top=0;//用数组模拟栈，不然会T for(int i=1;i&lt;=n;++i) { while(top &amp;&amp; !(a[S[top]]&gt;=a[i])) f[S[top--]]=i;//我们发现直接加入会破坏单调性，于是弹出栈顶元素，顺便计算当前元素的答案 S[++top]=i; } for(int i=1;i&lt;=n;++i) write(f[i]),putchar(' '); return 0; } 例题 $\\ \\ \\ \\ \\ \\ \\ $AT1225，CDQ分治套单调栈，较难。 $\\ \\ \\ \\ \\ \\ \\ $lucky52529的博客，自查第三题。 Junior Dynamic Programming——动态规划初步·各种子序列问题 一、 DPDPDP的意义以及线性动规简介 动态规划自古以来是 DALAODALAODALAO凌虐萌新的分水岭，但有些OIer认为并没有这么重要——会打暴力，大不了记忆化。但是其实，动态规划学得好不好，可以彰显出一个 OIerOIerOIer的基本素养——能否富有逻辑地思考一些问题，以及更重要的——能否将数学、算筹学（决策学）、数据结构合并成一个整体并且将其合理运用 qwqqwqqwq。 而我们首先要了解的，便是综合难度在所有动规题里最为简单的线性动规了。线性动规既是一切动规的基础，同时也可以广泛解决生活中的各项问题——比如在我们所在的三维世界里，四维的时间就是不可逆式线性，比如我们需要决策在相同的时间内做价值尽量大的事情，该如何决策，最优解是什么——这就引出了动态规划的真正含义： 在一个困难的嵌套决策链中，决策出最优解。 二、动态规划性质浅谈 首先，动态规划和递推有些相似（尤其是线性动规），但是不同于递推的是： 递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。 其次，由于每个状态均可以由之前的状态演变形成，所以动态规划有可推导性，但同时，动态规划也有无后效性，即每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责，可以浅显的理解为—— Future never has to do with past time ,but present does.\\mathcal{Future \\ \\ never \\ \\ has \\ \\ to \\ \\ do \\ \\ with \\ \\ past \\ \\ time \\ \\ ,but \\ \\ present \\ \\ does}.Future never has to do with past time ,but present does. 现在决定未来，未来与过去无关。 三、扯正题——子序列问题 （一）一个序列中的最长上升子序列（ LISLISLIS） 例：由6个数，分别是： 1 7 6 2 3 4，求最长上升子序列。 评析：首先，我们要理解什么叫做最长上升子序列：1、最长上升子序列的元素不一定相邻 2、最长上升子序列一定是原序列的子集。所以这个例子中的 LISLISLIS就是：1 2 3 4，共4个 1、 n2n^2n2做法 首先我们要知道，对于每一个元素来说，最长上升子序列就是其本身。那我们便可以维护一个 dpdpdp数组，使得 dp[i]dp[i]dp[i]表示以第 iii元素为结尾的最长上升子序列长度，那么对于每一个 dp[i]dp[i]dp[i]而言，初始值即为 111； 那么dp数组怎么求呢？我们可以对于每一个 iii，枚举在 iii之前的每一个元素 jjj，然后对于每一个 dp[j]dp[j]dp[j],如果元素 iii大于元素 jjj，那么就可以考虑继承，而最优解的得出则是依靠对于每一个继承而来的 dpdpdp值，取 maxmaxmax. for(int i=1;i&lt;=n;i++) { dp[i]=1;//初始化 for(int j=1;j&lt;i;j++)//枚举i之前的每一个j if(data[j]&lt;data[i] &amp;&amp; dp[i]&lt;dp[j]+1) //用if判断是否可以拼凑成上升子序列， //并且判断当前状态是否优于之前枚举 //过的所有状态,如果是，则↓ dp[i]=dp[j]+1;//更新最优状态 } 最后，因为我们对于 dpdpdp数组的定义是到i为止的最长上升子序列长度，所以我们最后对于整个序列，只需要输出 dp[n]dp[n]dp[n]( nnn为元素个数)即可。 从这个题我们也不难看出，状态转移方程可以如此定义： 下一状态最优值=最优比较函数（已经记录的最优值，可以由先前状态得出的最优值） ——即动态规划具有 判断性继承思想 2、 nlognnlognnlogn 做法 我们其实不难看出，对于 n2n^2n2做法而言，其实就是暴力枚举：将每个状态都分别比较一遍。但其实有些没有必要的状态的枚举，导致浪费许多时间，当元素个数到了 104−10510^4-10^5104−105以上时，就已经超时了。而此时，我们可以通过另一种动态规划的方式来降低时间复杂度： 将原来的dp数组的存储由数值换成该序列中，上升子序列长度为i的上升子序列，的最小末尾数值 这其实就是一种几近贪心的思想：我们当前的上升子序列长度如果已经确定，那么如果这种长度的子序列的结尾元素越小，后面的元素就可以更方便地加入到这条我们臆测的、可作为结果、的上升子序列中。 qwq一定要好好看注释啊！ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; f[i]=0x7fffffff; //初始值要设为INF /*原因很简单，每遇到一个新的元素时，就跟已经记录的f数组当前所记录的最长 上升子序列的末尾元素相比较：如果小于此元素，那么就不断向前找，直到找到 一个刚好比它大的元素，替换；反之如果大于，么填到末尾元素的下一个q，INF 就是为了方便向后替换啊！*/ } f[1]=a[1]; int len=1;//通过记录f数组的有效位数，求得个数 /*因为上文中所提到我们有可能要不断向前寻找， 所以可以采用二分查找的策略，这便是将时间复杂 度降成nlogn级别的关键因素。*/ for(int i=2;i&lt;=n;i++) { int l=0,r=len,mid; if(a[i]&gt;f[len])f[++len]=a[i]; //如果刚好大于末尾，暂时向后顺次填充 else { while(l&lt;r) { mid=(l+r)/2; if(f[mid]&gt;a[i])r=mid; //如果仍然小于之前所记录的最小末尾，那么不断 //向前寻找(因为是最长上升子序列，所以f数组必 //然满足单调) else l=mid+1; } f[l]=min(a[i],f[l]);//更新最小末尾 } } cout&lt;&lt;len; Another SituationAnother \\ \\ SituationAnother Situation 但是事实上， nlognnlognnlogn做法偷了个懒，没有记录以每一个元素结尾的最长上升子序列长度。那么我们对于 n2n^2n2的统计方案数，有很好想的如下代码（再对第一次的 dpdpdp数组 dpdpdp一次）： for(i = 1; i &lt;= N; i ++){ if(dp[i] == 1) f[i] = 1 ; for(j = 1; j &lt;= N: j ++) if(base[i] &gt; base[j] &amp;&amp; dp[j] == dp[i] - 1) f[i] += f[j] ; else if(base[i] == base[j] &amp;&amp; dp[j] == dp[i]) f[i] = 0 ; if(f[i] == ans) res ++ ; } 但是 nlognnlognnlogn呢？虽然好像也可以做，但是想的话会比较麻烦，在这里就暂时不讨论了 qwqqwqqwq，但笔者说这件事的目的是为了再次论证一个观点:时间复杂度越高的算法越全能 333、输出路径 只要记录前驱，然后递归输出即可（也可以用栈的） 下面贴出 n2n ^ 2n2的完整代码qwq #include &lt;iostream&gt; using namespace std; const int MAXN = 1000 + 10; int n, data[MAXN]; int dp[MAXN]; int from[MAXN]; void output(int x) { if(!x)return; output(from[x]); cout&lt;&lt;data[x]&lt;&lt;&quot; &quot;; //迭代输出 } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)cin&gt;&gt;data[i]; // DP for(int i=1;i&lt;=n;i++) { dp[i]=1; from[i]=0; for(int j=1;j&lt;i;j++) if(data[j]&lt;data[i] &amp;&amp; dp[i]&lt;dp[j]+1) { dp[i]=dp[j]+1; from[i]=j;//逐个记录前驱 } } int ans=dp[1], pos=1; for(int i=1;i&lt;=n;i++) if(ans&lt;dp[i]) { ans=dp[i]; pos=i;//由于需要递归输出 //所以要记录最长上升子序列的最后一 //个元素，来不断回溯出路径来 } cout&lt;&lt;ans&lt;&lt;endl; output(pos); return 0; } （二）两个序列中的最长公共子序列（ LCSLCSLCS） 1、譬如给定2个序列： 1 2 3 4 5 3 2 1 4 5 试求出最长的公共子序列。 qwqqwqqwq显然长度是 333，包含 3 4 53 \\ \\ 4 \\ \\ 53 4 5 三个元素（不唯一） 解析：我们可以用 dp[i][j]dp[i][j]dp[i][j]来表示第一个串的前 iii位，第二个串的前j位的 LCSLCSLCS的长度，那么我们是很容易想到状态转移方程的： 如果当前的 A1[i]A1[i]A1[i]和 A2[j]A2[j]A2[j]相同（即是有新的公共元素） 那么 dp[i][j]=max(dp[i][j],dp[i−1][j−1]+1);dp[ i ] [ j ] = max(dp[ i ] [ j ], dp[ i-1 ] [ j-1 ] + 1);dp[i][j]=max(dp[i][j],dp[i−1][j−1]+1); 如果不相同，即无法更新公共元素，考虑继承： $dp[ i ] [ j ] = max(dp[ i-1 ][ j ] , dp[ i ][ j-1 ] $ 那么代码: #include&lt;iostream&gt; using namespace std; int dp[1001][1001],a1[2001],a2[2001],n,m; int main() { //dp[i][j]表示两个串从头开始，直到第一个串的第i位 //和第二个串的第j位最多有多少个公共子元素 cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a1[i]); for(int i=1;i&lt;=m;i++)scanf(&quot;%d&quot;,&amp;a2[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { dp[i][j]=max(dp[i-1][j],dp[i][j-1]); if(a1[i]==a2[j]) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1); //因为更新，所以++； } cout&lt;&lt;dp[n][m]; } 222、而对于洛谷 P1439P1439P1439而言，不仅是卡上面的朴素算法，也考察到了全排列的性质： 对于这个题而言，朴素算法是 n2n^2n2的，会被 10510^5105卡死，所以我们可以考虑 nlognnlognnlogn的做法： 因为两个序列都是 1 n1~n1 n的全排列，那么两个序列元素互异且相同，也就是说只是位置不同罢了，那么我们通过一个 mapmapmap数组将 AAA序列的数字在 BBB序列中的位置表示出来—— 因为最长公共子序列是按位向后比对的，所以a序列每个元素在b序列中的位置如果递增，就说明b中的这个数在a中的这个数整体位置偏后，可以考虑纳入 LCSLCSLCS——那么就可以转变成 nlognnlognnlogn求用来记录新的位置的map数组中的 LISLISLIS。 最后贴 ACACAC代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int a[100001],b[100001],map[100001],f[100001]; int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){scanf(&quot;%d&quot;,&amp;a[i]);map[a[i]]=i;} for(int i=1;i&lt;=n;i++){scanf(&quot;%d&quot;,&amp;b[i]);f[i]=0x7fffffff;} int len=0; f[0]=0; for(int i=1;i&lt;=n;i++) { int l=0,r=len,mid; if(map[b[i]]&gt;f[len])f[++len]=map[b[i]]; else { while(l&lt;r) { mid=(l+r)/2; if(f[mid]&gt;map[b[i]])r=mid; else l=mid+1; } f[l]=min(map[b[i]],f[l]); } } cout&lt;&lt;len; return 0 } Although there′re difficulties ahead of us , remember :\\mathcal{Although \\ \\ there&#x27;re \\ \\ difficulties \\ \\ ahead \\ \\ of \\ \\ us \\ \\ , \\ \\ remember \\ \\ :}Although there′re difficulties ahead of us , remember : 就算出走半生，归来仍要是少年 ","link":"https://hesy-zhoulijie.github.io/csp-js-algo/"},{"title":"Gridea同步测试","content":"不知道为什么，我发现10/5的博客同步不见了。。。 ","link":"https://hesy-zhoulijie.github.io/69BiRqwaU/"},{"title":"查天气、搜歌词、监控系统状态…… 用这些 App 把 Mac 菜单栏变成万能工具箱","content":" 查天气、搜歌词、监控系统状态…… 用这些 App 把 Mac 菜单栏变成万能工具箱 为了彰显存在感，各路 Mac 应用都喜欢在菜单栏上安置一个图标：其中有的只是用来召唤主界面，也有一些应用发掘了更多用途，真正利用好了 macOS 菜单栏这块「宝地」。 今天，就让我们来认识一下 21 款各具特色的工具 App，它们能够让寸土寸金的菜单栏物尽其用，打造成专属于你的万能工具箱。 One Switch 桌面文件总显得凌乱无序、临时离开又想保护隐私…… 这些琐碎需求，One Switch 帮你一站解决。它整合了隐藏桌面图标、切换黑暗模式、始终保持亮屏、快速进入屏保和切换 AirPods 5 项实用功能，都可以一键开启。开发者称，未来还会加入更多新特性，敬请期待。 你可以在 官网 购买 One Switch，国内定价为 30 元。 Amphetamine 一段时间未操作后，Mac 就会进入休眠状态，但如果你正在演示 Keynote 或观看视频，或许希望给电脑打针「兴奋剂」，Amphetamine 就是个不错的选择。它不仅可以临时阻止 Mac 休眠，还提供了丰富的自定义选项，可以在指定时间段、运行特定 App、连接至指定 WiFi 等情况下自动启用。 你可以在 App Store 免费获取 Amphetamine。 NightOwl 尽管 One Switch 已经提供了切换黑暗模式的选项，但现在流行的是依据时间自动切换主题。而 NightOwl 这款小工具不仅允许你计划时间段，还能通过位置信息在日出日落时自动切换模式。此外，你还可以让指定 App 始终保持浅色外观，使用更舒心。 你可以在 官网 免费获取 NightOwl。 Infinity Dashboard 在这个信息过载的时代，我们每天都需要了解各方面动态：天气、日历、股票、汇率、社交网络……Infinity Dashboard 就将这些信息整合到了一起，只需点击菜单栏图标，就能尽知天下事。 你可以在 官网 以 9.99 美元的价格购买 Infinity Dashboard。 关联阅读：看日历、查汇率、等商品降价……只需扫一眼 Mac 菜单栏：Infinity Dashboard RunCat 在菜单栏显示实时 CPU 占用率的 App 你或许见得多了，但像 RunCat 这么有趣的可谓独一份。它将 CPU 负荷浓缩为 GIF 动图，电脑越卡，菜单栏的猫咪就跑得越快，纾解心中压力。除了默认的🐱外，RunCat 还提供了🦆、🐴、🐧、🐙等多种主题，满足各种喜好。 你可以在 App Store 免费获取 RunCat，🐶、🐸、🐲、🎄等主题及自定义皮肤功能需要付费解锁。 网速 &amp; 电池 顾名思义，网速 &amp; 电池是一款可以显示实时网速、存储占用及电池状态的小工具。它提供了多种显示方式，并适配了 macOS Mojave 的黑暗模式。除了菜单栏外，网速 &amp; 电池还支持通知中心小组件和置顶悬浮窗口，助你快速了解系统状态。 你可以在 App Store 以 12 元的价格购买网速 &amp; 电池。 iStat Menus 6 iStat Menus 6 同样是一款系统状态监控工具，它涵盖了 CPU、GPU、内存、磁盘、网络、电池、传感器等各种模块，信息详尽，并支持自由定制。你还可以添加触发器，在电池电量不足、内存占用过高等情况下收到推送通知。 你可以在 官网 以 11.99 美元的价格购买 iStat Menus 6，应用同时包含在 Setapp 订阅中。 关联阅读：不仅系统监控要做得更出色，iStat Menus 6 还能让你在状态栏看天气了 Itsycal macOS 原生的菜单栏时钟着实有些简陋，不仅无法查看日程，连今天是几月几号都无从知晓。而 Itsycal 就是个不错的补充，它允许你在菜单栏查看日历月视图及接下来的事项安排，并自定义日期格式、高亮等。 你可以在 官网 免费获取 Itsycal。 关联阅读：Fantastical 太贵了？试试免费的菜单栏日历工具：Itsycal PicGo PicGo 是一款免费开源的跨平台图床工具，可以通过快捷键或菜单栏图标快速上传剪贴板内图片。它预置了微博、SM.MS、GitHub、阿里云、腾讯云等 8 家主流图床服务，并可以通过插件扩展更多玩法。 你可以在 GitHub 免费获取 PicGo 的 macOS、Windows 和 Linux 版本。 关联阅读：图床「神器」PicGo v2.0更新，插件系统终于来了 Sip 无论是设计海报、UI 界面还是其它作品，颜色搭配都是件重头戏。不过，要想调配出与主题相契合的色彩组合并不是那么简单，而 Sip 就能从任意界面提取颜色，并生成色卡，还支持一键复制为多种代码格式。 你可以在 官网 以 10 美元的价格购买 Sip，应用同时包含在 Setapp 订阅中。 关联阅读：设计师的好帮手，萃取生活里的缤纷色彩：Sip Color Pomo Timer Pomo Timer 是一款常驻在菜单栏上的番茄钟工具，其 UI 简洁美观，支持设定番茄时长、计划任务、通知样式等，可以帮助你轻松创建和管理番茄定时器。如果你不喜欢默认番茄图片，还可以自行替换为其它图像，更有乐趣。 你可以在 App Store 免费获取 Pomo Timer，自定义番茄图片功能需要内购解锁。 Mate Translate Mate Translate 是一款菜单栏翻译工具，支持自动检测源语言、自动翻译剪贴板、快捷键呼出及音标、拼音显示等。由于其采用 Google 作为底层翻译引擎，保证了翻译的准确性，同时比网页 Google 翻译更方便快捷，随用随取。 你可以在 App Store 以 198 元的价格购买 Mate Translate，并在 官网 获取其它平台版本，应用同时包含在 Setapp 订阅中。 ToothFairy 尽管 AirPods 支持在苹果全家桶间无缝切换，但在没有状态指示的 Mac 上，依然可能出现外放响彻整个图书馆的尴尬。有了 ToothFairy，你就可以在菜单栏图标上看到所有蓝牙设备的连接状态及剩余电量，并通过点击或快捷键快速切换。 你可以在 App Store 以 18 元的价格购买 ToothFairy，应用同时包含在 Setapp 订阅中。 关联阅读：如果你在 Mac 上用 AirPods 和 BeatsX，ToothFairy 能帮你一键切换 LyricsX 如果你正在使用 Apple Music 或 Spotify，或许会怀念国内音乐 App 的歌词显示及滚动功能。而 LyricsX 就能自动识别 iTunes、Spotify 和 Vox 上播放的歌曲名称，并匹配对应歌词，在菜单栏、悬浮窗或独立窗口中动态显示。 你可以在 App Store 和 GitHub 免费获取 LyricsX。 休息一下 我们都知道，长时间面对电脑屏幕对视力损害极大，但却很难管住自己；若是使用番茄钟，5 分钟的休息时间又难免打断工作状态。而休息一下则利用 20-20-20 视力保护原则，每过 20 分钟提醒你休息 20 秒，并将视线转移至 20 英尺（约 6 米）外的物体上，既纾解眼部压力，又不会因时间过长而影响正常工作。 你可以在 Mac App Store 免费获取休息一下。 Noizio 终日生活在狭小的格子间中，你可能会向往大自然的怀抱。而 Noizio 这款白噪音应用，就能播放秋雨、雷鸣、柴火、海浪、溪流等多种声音，并支持混合音效配置，舒缓身心，释放压力。 你可以在 App Store 以 30 元的价格购买 Noizio，应用同时包含在 Setapp 订阅中。 Irvue 看腻了一成不变的桌面，又无暇寻觅新的壁纸，有了 Irvue，这些都不是问题。它可以自动获取 Unsplash 上的精选照片并定期更新，还提供了点赞、下载、加入黑名单等操作，让你每天都有新惊喜。 你可以在 App Store 免费获取 Irvue。 关联阅读：你只需要欣赏桌面，把换壁纸的事交给 Irvue 就好了 Kaomoji Lover Kaomoji Lover 是一款常驻在菜单栏上的卖萌神器，它收集了超过 18000 个表达各种情绪的颜文字，只需点击菜单栏上的图标，就能轻松复制并插入任何你喜欢的表情，让聊天更有趣。 你可以在 App Store 下载 Kaomoji Lover，售价 ¥50。 HazeOver Mac 窗口一多，往往会忘记当前焦点是哪个，HazeOver 则可以为非活动窗口加上一层阴影，帮助你专注于当前工作。在偏好设置中，你还可以设置遮罩颜色、透明度及快捷键等，方便省心。 你可以在 App Store 以 68 元的价格购买 HazeOver，应用同时包含在 Setapp 订阅中。 Bartender 3 安装了上文介绍的 App 后，如何整理多到溢出的菜单栏图标又成了件烦心事，而 Bartender 3 就能帮助我们将用不到的图标藏起来。它的原理是给菜单栏加上一块「平行」区域，点击图标即可切换，眼不见心不烦。 你可以在 官网 以 15 美元的价格购买 Bartender 3，提供 4 周免费试用。 关联阅读：不仅要能藏，还要藏得优雅，Mac 菜单栏简化工具 Bartender 3 更新 Dozer Bartender 虽好，价格却略感人，完全免费的 Dozer 就是个不错的替代品。它的操作十分直观，只需按 ⌘Command 拖动菜单栏图标，将想隐藏的项目拖到两个标志点的左侧，点击后就会被收纳，再次点击即可展开，轻量简单。 你可以在 官网 免费获取 Dozer。 关联阅读：一个完全免费的 macOS 菜单栏工具，一拖一点就能轻松隐藏图标：Dozer 你还有哪些好用的 macOS 菜单栏工具想要与我们分享，欢迎在评论区告诉我们。 ","link":"https://hesy-zhoulijie.github.io/mac-taskbar/"},{"title":"Apple WWDC 2019","content":"Apple WWDC 2019 iPad 有了自己的系统，还有新 Mac Pro…… 昨晚发布会要点都在这了 北京时间今日凌晨 1 点，苹果在美国加州的圣何塞会展中心召开了一年一度的 WWDC 全球开发者大会。作为受邀媒体，少数派今年继续全程在美国现场报道本次开发者大会。在将近 2 个半小时的开幕演讲中，苹果发布了拥有全局深色模式的 iOS 13、全新独立系统的 iPadOS 以及 watchOS 6 和 tvOS 13。 作为 WWDC 的惯例，本次新系统的发布依旧是发布会的重点，不管是独立出去的 iPadOS 还是推出 Project Catalyst 的 macOS，对于消费者和开发者都是一件影响颇深的事件。与此同时，模块化的高性能 Mac Pro 终于也带着全新的设计回归，而支持 Retina 6K 和 Pro Display XDR 的专业显示器也赚足了眼球。 iOS 13 作为本次 WWDC 的重头戏，iOS 13 闪亮登场。继去年深色模式登陆 macOS 之后，iPhone 和 iPad 也终于拥有了自己的深色模式，并且为照片应用新增了强大的浏览和编辑功能、提供以 Apple ID 登录应用或网站的选项以及可以在地图中获得更多的信息。 除了新增功能，iOS 13 在性能优化上也有出色的表现，例如应用启动速度提升了两倍、应用更新速度也有提升等。 对眼睛更友好的深色模式 千呼万唤始出来，传了多年的 iOS 深色模式终于发布了。这次发布的 iOS 深色模式和 macOS 上的深色模式一样都是系统级的，所有的界面以及自带应用都已经适配了深色的配色方案，在低光情况下有很好的表现，屏幕看起来让眼睛更加舒服。 除了系统自带应用，苹果也向第三方应用的开发者开放了接口，开发者们也可以方便地让自己的应用适配 iOS 的深色模式。除了手动启用，iOS 的深色模式也可以通过设定固定的时间或者依据当地的日出日落时间来自动切换。 更加强大的照片编辑工具 有机器学习加持之后，照片应用获得了更加强大的功能。首先，照片应用可以通过突出最好的照片、自动隐藏杂乱或者重复的照片来更好地展示过去的一天、一月或一年中重要的事件，巧妙地结合照片和视频，让使用者在浏览、发现和重温最喜欢的回忆时变得更加容易。 其次，照片应用获得了丰富的编辑功能。只需轻轻一滑，你就可以轻松地调整照片的特效，通过原生的功能解决了调用第三方工具的繁琐，为摄影爱好者们提供了更多的创造可能性。除了照片，iOS 13 的照片应用还可以直接编辑视频，用户可以直接在其中旋转、裁剪和使用滤镜，方便了很多。 同时，人像模式新增了一个光线调节和一个 High-Key Mono 效果的选项，可以创造出更加好看的肖像照片。 便捷、私密的苹果账号登录 越来越多的网站需要我们使用手机、邮箱、社交账号等来注册和登录，不但不方便管理，而且极易泄露自己的隐私。 苹果这次推出了使用 Apple ID 登录的功能，轻松、简单地完成身份验证和登录网站。同时，为了保护使用者的隐私，苹果允许用户隐藏自己的邮箱地址，甚至可以自动生成一个随机的邮箱地址来替代。用户使用 Apple ID 来登录的时候，可以通过 Face ID 或者 Touch ID 来验证，加上双重验证，不但方便而且还确保了自己的隐私不会被泄漏。 全新的地图体验 为了让 iOS 用户获得更好的地图使用体验，苹果在驱车 400 万英里收集数据后开始重构地图应用。在 iOS 13 的全新地图应用中，用户可以获取到更广泛的道路覆盖范围、更好的行人数据、更精确的地址和更详细的土地覆盖，并将在近两年推广到更多的国家和地区。 iOS 13 的地图应用新增了街景的功能，所有的图像由全新的基础地图和高分辨率的 3D 摄影构成，帮助环顾功能提供了一个平滑无缝过渡的街景浏览体验。除此之外，地图应用还可以轻松分享最喜欢的餐厅、旅游目的地或者与朋友购物的地方，或者导航到常去的目的地，如家、办公地点、健身房或学校等。 其他值得一提的功能： 提醒事项应用重做，UI 设计交互完全改变，新增的快速工具栏可以方便地添加时间、日期、地点、旗标以及附件； 信息应用可以自动共享用户的姓名和照片、Memoji 或者 Animoji，同时 Memoji 可以制作成贴纸在自带应用和第三方应用中使用； 借助 Neural TTS ，Siri 有了一个更加自然的声音，并且提供更加个性化的自动化推荐； AirPods 可以通过 Siri 来读取和回复信息； 语音控制可以让用户完全通过语音来控制 iPhone、iPad 和 Mac； 原生键盘提供了滑动输入的选项。 iOS 13 升级仅支持 iPhone 6S 及之后推出的手机，以及 iPod touch 7。 iPadOS 在第一代 iPad Pro 发布将近四年之后，Apple 终于正式将 iPad 作为一个独立的平台与 iOS 独立开来，进一步强调了 iPad 的生产力属性，并在本次为它带来了许多独占功能。 多任务处理 本次 iPadOS 最大的更新在于对多任务处理的巨大改进。首先，Slide Over 从一个单纯的悬浮窗口变为了一个拥有完整功能的窗口模式。在本次更新后，你可以通过滑动应用窗口顶部的 Home Indicator 来切换应用，相当于在原来的多任务中心之外又嵌套了一个专属于 Slide Over 的多任务中心。 关闭 Slide Over 中的应用窗口也是一样的操作，只需将应用卡片上滑退出即可。若想将 Slide Over 中的应用设为全屏应用，则需将应用窗口拖拽至屏幕的顶部。 与此同时，iPad 终于支持了同一应用的分屏模式，而不再像之前只能使用两个应用同屏。 除了单纯的分屏模式，同一应用还可以同时在分屏模式和 Slide Over 模式下同时使用。如果你想查看同一应用的不同位置，你可以使用从 macOS 新引入的 App Exposé，只需点击它在 Dock 上的图标即可进入 App Exposé 视图。 除了拖拽窗口，现在直接拖拽链接、地址等信息也可以创建新的应用窗口，免去了先打开应用的麻烦。 主屏幕能摆更多图标了，还能直接看小组件 在 全新的 iPadOS 中，主屏现在可以放下更多的应用。另外，iPadOS 直接去掉了 iOS 上的负一屏，如果要在 iPadOS 上查看小组件，只需要通过右滑手势，就可以直接在主屏幕拉出控件，和主屏图标一起显示，利用小组件查看信息或者进行一些快捷操作会变得更加方便。 文件应用更像 Finder 了，Safari 新增下载管理器 作为一个主打生产力的平台，系统文件应用在 iPadOS 中更新自然不会让人意外。新版文件应用支持了最多达 3 栏的显示视图，你还可以直接在文件应用中预览文件的各项信息—比如类型、大小、修改时间、图片的分辨率等等—而不用打开文件。 iOS 12 中文件应用虽然能共享文件，但是没有支持文件夹共享功能，iPadOS 终于补上了这一功能。你可以直接在文件应用里将文件夹共享给别人、或者连接别人共享出来的文件夹。除了共享云端文件，iPadOS 支持将 U 盘、SD 卡等外部存储设备连上 iPad，直接读取里面的文件。 在文件管理方面，Safari 也有新动作：终于支持了下载管理器。管理下载文件也非常简单：在系统文件应用找到下载文件夹就可以了。 除了下载管理器，Safari 在网页浏览方面也有比较大的改进：iPadOS 会直接在 Safari 中展示桌面版网页，并对一些需要鼠标操作的元素进行了触控优化，让你可以获得足够优秀和流畅的桌面级网页浏览体验。 打字更方便了，也更快了 iPadOS 支持的 Floating Keyboard 浮动键盘能够让你通过双指捏合手势将键盘变为一个可拖动的悬浮窗口，如果你没有在用 Smart Keyboard 等外接蓝牙键盘设备，用双指捏合手势将键盘拖到左右手的任意一边打在效率应该会高不少。 除了双指捏合手势，iPad OS 还新增了三指捏合复制、张开粘贴文字以及三指左滑撤销手势，按照发布会上的说法就是，你再也不用摇晃大尺寸的 iPad 来撤销误输入的文字了。 此外，iPadOS 还支持了单指拖动选中指定文字、双击选中单词等实用手势，在输入效率方面的提升还是比较明显的。 其它值得关注的 iPadOS 特性： Apple Pencil 的响应延迟时间由 20ms 提升到了 9ms； Apple Pencil 工具栏支持拖拽移动位置，将 Apple Pencil 移到 iPad 屏幕角落会触发截图操作并自动弹出标注界面； 新增 Sidecar 功能，让你通过 Wi-Fi 将 iPad 作为 Mac 的第二显示屏； 在 iPadOS 上用 Face ID 解锁速度比 iOS 12 快了 30%； 与 iOS 同步支持 Voice Control、AirPods 共享、HomePod 上的 Handoff 音频传输等功能； 支持下载和管理字体。 iPadOS 更新仅支持 iPad Air 2 及之后推出的 iPad、iPad Pro 和 iPad mini。 macOS 10.15 今年苹果把 macOS 10.15 命名为 macOS Catalina。正如此前爆料所言，今年的 macOS 第一个主要的新变化便是将 iTunes 进行了拆分。三个全新的 App：音乐、播客和 TV 将取代 iTunes，而此前同步与备份 iOS 设备的功能在新版系统里则被集成到 Finder 中。 在机器学习的帮助下，新的播客应用拥有更强大的搜索功能。现在输入关键词后，应用将为你直接搜索音频内容中出现该关键词的播客。 新的 TV 应用则支持在 Mac 上播放 4K HDR 内容，此外还提供了杜比视界和杜比全景声的支持。 另外新版的提醒事项和照片应用也将同步登陆 macOS Catalina。 macOS Catalina 第二个主要的新功能是 Sidecar，它可以让你的 iPad 变身成为 Mac 的拓展屏幕。不仅如此，在新系统中你还可以把 iPad 当作 Mac 的手写板或绘图板来使用，用 Apple Pencil 直接在屏幕上画画和批注。该功能目前支持包括 Adobe Illustrator、Affinity Photo 和 Maya 在内的多款专业级应用。 去年苹果在 iOS 上推出了屏幕时间功能，让你可以了解和控制自己花费在 iOS 设备上的时间。今年 macOS Catalina 则把这项功能带到了 macOS 上。 苹果系统在辅助功能方面体验一直走在行业的前列。macOS Catalina 今年则在语音控制上更进一步，现在用户可以完全通过语音来控制使用 macOS，从打开应用、选择菜单功能再到输入文字，整个流程完全可以通过语音指令完成。 macOS Catalina 中还新增了一个名叫「查找」的新 App。它集成了 iOS 上查找 iPhone 和查找我的朋友两款应用的功能。此外它还新增了一个可以查找未联网 Mac 的功能。另外配有 T2 安全芯片的 Mac 还可以在新系统中增加启动锁。 苹果曾在去年介绍过帮助开发者将 iPad 应用快速迁移至 macOS 上的 Marzipan 项目，今年苹果将它正式命名为 Project Catalyst。苹果表示他们在过去的一年里做了大量的工作，来保证迁移项目能够得到更流畅的体验。发布会上苹果表示包括 Twitter、Jira 和 Gameloft 在内的多家第三方厂商正在参与这一项目，对自家的应用进行适配。 最后，设备支持方面，macOS Catalina 支持 2015 年及之后的 MacBook，2012 年及之后的 MacBook Air、MacBook Pro、Mac mini 和 iMac，2017 年及之后的 iMac Pro 以及 2013 年及之后的 Mac Pro。 watchOS 6 作为 watchOS 的第 6 个版本，watchOS 6 终于有了独立的 App Store 应用，这意味着你可以直接在 Apple Watch 上搜索、下载和运行应用，不再需要依赖 iPhone。Apple Watch 上的 App Store 支持语音和 Scribble 手写两种搜索应用的方式，你也可以在 Apple Watch 上直接查看 App Store 编辑的推荐或者来自用户的评价。 除了 App Store，watchOS 6 也将计算器、语音备忘录和有声书三款应用带到了 Apple Watch 上，其中计算器应用还支持了小费计算这样的实用功能。 其它值得关注的 watchOS 新特性有： 新增渐变色、大数字、模块化等多个新表盘样式。 新增运动记录趋势分析功能，watchOS 会根据你的运动情况给出调整建议，并同步在 iOS 中的「健身记录」应用中进行展示。 新增月经周期记录功能，支持月经、排卵期提醒等。 新增环境噪音检测功能，并会在当前环境噪音过大时进行提醒。 新增正点报时功能。 watchOS 支持包括 Apple Watch Series 1 在内之后的全部 Apple Watch 设备，不支持初代 Apple Watch。要想升级 watchOS 6，你需要有一台 iPhone 6s 或更新的 iOS 设备，并且确保 iPhone 升级到了 iOS 13 或者更新的系统版本。你可以在 Apple 官网查看 watchOS 6 的详细信息。 tvOS 13 tvOS 13 支持了多账号功能，并且会根据每位家庭成员的观影记录进行个性化推荐，Apple Music 还支持实时显示正在播放歌曲的歌词。 在游戏娱乐方面，tvOS 13 支持了 Xbox One 和 PS DualShock 两款游戏手柄，在 Apple TV 上玩游戏将能够获得更好的游戏体验。最后，Apple 还与 BBC Natural History 纪录片剧组合作，在 tvOS 13 上带来了一系列 HDR 高清海底壁纸，让你在家就能拥有身临其境的海底世界体验。 tvOS 13 支持目前在售的 Apple TV 4K 和 Apple TV HD 两款型号设备，你可以在 tvOS 官网查看 tvOS 13 的新特性。 iOS 13、iPadOS、macOS Catalina、tvOS 13 和 watchOS 6 的 Beta 测试版本目前已经开放给开发者进行下载，7 月份会对所有人开放公开测试版本。如果你担心测试版本的系统可能会有不稳定的情况，可以等到今年秋季更新这些系统的正式版本。 Mac Pro 和 Pro Display XDR 2017 年 曾有消息 传出苹果正在重新设计 Mac Pro。时隔两年，苹果终于在本次 WWDC 上正式推出了这款全新的 Mac Pro。 新款 Mac Pro 回归了经典的塔式机箱外形，整个结构采用模块化设计。侧边则采用了类似「擦丝器」的镂空设计，底部可选配 4 个方便移动用的轮子，设计语言与上一代大相径庭。 苹果称这个设计主要是为了新款 Mac Pro 强大的配置而服务，事实也的确如此。新款 Mac Pro 最高可选配 28 核的英特尔至强处理器和 1.5TB DDR4 ECC 的内存。它同时配有 8 个 PCIe 接口，其中 4 个提供 double-wide 设计以适应更大的拓展卡。 为了提供充足的视频性能，苹果还专门为新款 Mac Pro 设计了一个名为 MPX 的拓展模块，它可以为两块显卡提供高速连接。新款 Mac Pro 可最高选配 2 个带有 2 块 AMD Radeon Pro Vega 2 显卡的 MPX 模块，这意味着它能够提供高达 128GB 的 HBM2 高速显存。 不仅如此，新款 Mac Pro 还配有一个专门的硬件加速卡，用于处理 4K 甚至是 8K 视频的渲染和转码，每秒可处理 63 亿像素的数据，满足专业人士对于剪辑 ProRes Raw 素材的需求。 接口方面，新款 Mac Pro 则提供了 4 个雷雳 3 接口，2 个 USB-A 接口 和 2 个 10Gb 以太网接口。 新款 Mac Pro 起售价 5999 美元，配有 32GB 内存、8 核心至强处理器、Radeon Pro 580X 显卡以及 256GB SSD 硬盘。今年秋季正式发售。 此外，苹果还推出了 Pro Display XDR 专业级显示器。它拥有一块 32 寸的 IPS LCD 屏幕，分辨率为 6016x3384，苹果称其为 Retina 6K Display。这款显示器在对比度方面达到了 1,000,000:1 的标准，亮度为 1000 nits，峰值亮度可达 1600 nits，苹果表示它在 HDR 上表现非常出色，超过了一般的行业标准，因此他们把它称为 Extreme Dynamic Range，简称「XDR」。 为了提供更出色的显示体验，苹果还为 Pro Display XDR 设计了一个多角度可调的桌面支架，支持竖屏模式显示。另外 Pro Display XDR 还可选配带有 Nano-texture 处理的屏幕，可在保证屏幕显示效果的同时降低屏幕的反射率。 Pro Display XDR 售价为 4999 美元，带有 Nano-texture 屏幕的版本售价为 5999 美元，桌面支架需单独购买，售价 999 美元，今年秋季正式发售。 ","link":"https://hesy-zhoulijie.github.io/wwdc19/"},{"title":"Mac 电脑终极选购指南","content":"Mac 电脑终极选购指南 我自己是从 2012 年开始使用 Mac 的，而且基本上经历过了 MacBook、MacBook Air、MacBook Pro、iMac、iMac Pro，应该可以说非常了解了。其实我在今年年初写过一篇文章，系统地介绍过 Mac 的购买和使用，目前仅在知乎就有超过 8000 的点赞和 100 万的阅读量。但是今年苹果对于 Mac 的更新节奏特别快，几乎多数的产品线都有或多或少的更新，所以当时那篇文章现在已经完全不适用了。 所以，也就有了今天这一篇。 在这篇文章中，还是主要回答两个问题： Mac 是不是适合你？ Mac 哪一款适合你？ Mac 是不是适合你？ 在很长一段时间里，拥有一台苹果电脑来说是一件很「装逼」的事情。在星巴克，抿一口拿铁，打开 MacBook Air，当信仰标志亮起的一刻，仿佛自己就是世界的焦点。所以每当我们提到苹果电脑的时候，大家的第一印象一定是「装逼」和「贵」。 再好的工具，也一定有适用人群，所以为了节约大家的时间，如果你是我说的以下几种人，就没必要往后阅读了： 游戏爱好者。想要在电脑上打游戏，任何门类的游戏，无论是主机游戏，还是网络游戏，Mac 电脑都不适合。 专业软件不支持 macOS 。这个因为情况较多，需要你自行了解。一般来说，你可以向同事了解，公司是不是有仅在 Windows 上才能运行的专业软件。如果是学生，就向学长学姐了解一下你的专业是不是有无可代替的软件一定要在 Windows 上运行。目前已知的是，像一些金融或者是财会类的软件在 Mac 上要么无法运行，要么就是像 Excel 这种软件，在 Mac 上运行功能会有阉割，例如 CAD 虽然可以用，但是表现不好。 预算不够。目前来看，如果你买电脑的预算不是 8000 以上，就请不要考虑 Mac。因为，无论怎么说， Mac 依然属于昂贵的电脑。 那么你选择 Mac 的理由是什么呢？ 系统的稳定 我先提前打预防针，我知道一定会有人评论稳定性已经不如从前了等等，但不得不承认，今天 macOS 的稳定性依然是远超 Windows。尤其是对一些女孩子来说，macOS 省心省力。macOS 因为特殊机制，避免了普通用户乱下载软件，或不小心下载流氓软件，甚至是中毒的风险。 系统的流畅度 这也是 Mac 的核心优势之一。这种流畅度也很好理解，你如果使用过 iPhone 和安卓机，就会发现配置再好的安卓机感觉上还是不如 iPhone 流畅，这个结论在 Mac 上也是成立的。 创意工作的沉浸体验 为什么几乎所有的摄影师和音乐创作者都会选择 Mac 电脑，就是因为整个系统的沉浸体验极佳。所有的创意工作都非常在意所谓的「灵感」，Mac 系统可以让你全身心投入，不会有「广告弹窗」打扰你，尤其是像是 Photoshop 和 Lightroom 这种软件，在 Mac 上运行行云流水。除非你的配置太老，基本上 Photoshop 都是秒开，这一点对创作全靠心情的摄影师很重要。 而对视频剪辑来说，Final Cut Pro 这款软件仅仅只能在 Mac 上使用，所以很多喜欢这款软件的用户也会优先选择 Mac。而如果你选择了 Mac，请你一定要学会使用它，因为它是最容易上手且专业的视频剪软件。 优秀的屏幕及影音体验 Mac 的这一块 Retina 屏幕绝对是目前笔记本行业里的标杆。你要记住的是，虽然参数上不是极致的，例如现在的笔记本动不动就是 4K 分辨率，但是得益于苹果的软硬结合，尤其是在字体渲染等方面 macOS 有着自己独特的优势，在实际观感上绝对是上乘，而 Windows 电脑对于高分辨率的支持实在是落后更加明显。 说到音响，Mac 更是有着绝对顶级的表现，尤其是 MacBook Pro 的音响，可以用「震撼」这个词来形容。 优秀的外观和工业设计 我相信，这是很多女孩子种草 Mac 最重要的原因之一。Mac 电脑的设计都是需要经过长时间的考验，这也就意味着，你选择的是一个经久不衰的外形设计。例如，即使这一次在更新 MacBook Pro 的时候，外形并没有改变，它依然颜值出众。 苹果生态的紧密结合 如果你除了 Mac 以外还使用其他苹果产品，那么你会感受到苹果生态的魅力。最简单的，如果你使用 iPhone 可以无缝使用隔空投送传递文件。而如果你现在有 iPad，甚至是可以使用随航功能，你的 iPad 可以成为 Mac 的第二块屏幕，甚至是数位板。 对了，这里有一点非常重要的声明，就是说 Mac 是有 Office 的，这也是大多数人误会最多的地方。Mac 上的 Office 套件可以正常使用，只不过会有一些专业功能的阉割，尤其是在 Excel 上，当然，如果你不是重度用户就不需要担心。一个小番外，其实 Office 本来就是乔布斯邀请盖茨做的，这个故事非常有意思，有机会再分享给大家。 但是，我一定要再强调一次，上述所说的所有一切都是建立在你使用 macOS 的基础上，如果你买回来就装了一个 Windows，那以上的优势几乎没有。 如果你看到这里，决定要购买 MacBook（Pro），那么接下来你可以继续思考之前我说的两个问题，它们决定着你能不能买到真正适合自己的 Mac。 问题一：你的预算是多少？ 这非常关键，只有在搞清楚这个问题以后，我们后面才会有讨论的必要。在你做出预算的时候，需要清楚一件事： 「Mac 是昂贵的电脑，但也是有着高性价比的电脑」 这个说法看起来是矛盾的，但我们可以简单地做这样一个计算：目前，苹果官网最便宜的 Mac 是 MacBook Air，售价是 8899。什么概念？这个价格可以买到市面上绝大多数品牌电脑的高配版本，而你在 Apple 这里却只能买一个「只能打打字，看看剧」的上网本（当然了，这可能是最好看的上网本）。 所以，Mac 贵吗？当然贵。 那么高性价比从何而来呢？ 我上一个笔记本电脑是 MacBook Pro 2012 款，这款电脑我一直用了 5 年，最后换掉的原因并不是因为卡顿，只不过是因为我剪辑视频要上 4K，实在是难为一款 5 年前的电脑。也就是说，任何一款 Mac 的寿命一定是三年以上，而且三年以上运行依然流畅，4-5 年才会感受到电脑配置不够用。 对于很多仅仅是当作上网本的用户，轻轻松松用个 4-5 年没问题，但是对于任何一款 Windows 笔记本，别说 3 年以上，2 年不到绝对就会变成开机等一分钟的状态（绝大多数的使用者）。 如果是对于缺乏电脑常识的用户，用不了多久电脑就会变成各种流氓软件全家桶，所以，不夸张地说，Mac 的使用寿命是 Win 的两倍。 因此，只要是适合的人，Mac 的确是有性价比的，甚至是像 iMac 5K 这样的产品更是极具「性价比」。 好，说了这么多，现在你可以想想到底可以拿出多少钱来购买 Mac 。 这个数字一定是你的最高预算。 问题二：你的需求是什么？ 这是一个比价格还要难回答的问题，很多人对自己的需求并不是很确定，但是你一定要有一个轻重缓急的排序，例如你是更加看重颜值、重量，还是性能和屏幕尺寸。 假设，我们的电脑是用来修图学摄影，那么屏幕尺寸和性能就是需要优先考虑的要素，便携性就需要让步。需要记住的是，没有完美的电脑，比如便携性和性能同时达到完美是不可能的。而且，并不是纸面上的参数性能越好就越适合你，其实对于绝大多数人来说，Mac 的性能都是过剩的。 在有了以上的准备工作以后，我们现在终于可以走进 Mac 的世界。 哪一款 Mac 适合你 目前的 Mac 电脑已经横跨了各个用户群体，从普通到专业。在本文中，因为需要考虑更多的受众，所以非常专业的 Mac 例如 iMac Pro、Mac Pro、Pro XDR Display 这些设备将不会涉及。而且我也相信这些用户本身应该比我更了解 Mac，所以接下来，我会把目前官网在售的 Mac 分为六个型号： MacBook Air 目前所有的在售笔记本中，MacBook Air 是性能最弱的一个，不过相应的也是价格最低的一款，官网售价是 8899 起步。 这是一款标准的上网本，优点有： 强续航。因为不需要很强的性能，所以能耗控制得很好，这也是目前在售的笔记本中续航最好的一款，基本上充一次电就可以满足一天使用，可以说摆脱了充电线的困扰，带到哪里都不需要找充电插座。 高颜值。颜值对于很多用户来说都是非常重要的指标，尤其是对于女性用户。MacBook Air 经典的楔形设计，尤其是玫瑰金色，可以很好地搭配衣服和包包，颜值出众。 轻机身。这里的轻，并不是机身轻，而是考虑到携带充电器以后的整体重量。 它的缺点有： 性能不够强劲。但是正如一开始所说，性能是因人而异的。换句话说，性能是相对的。如果你平时就是看看剧，写写文档，处理一些工作任务绰绰有余。哪怕是适度的照片处理也是没问题，4000 万像素的 Raw 格式也带得动，但是剪辑一个 4K 影片肯定是不行的。 屏幕色彩素质相对较低。在目前的 Mac 型号中，MacBook Air 仅仅覆盖了100% sRGB，而其它都已经是标准的 P3 广色域，所以如果你从事的职业对于色彩有要求，那么就需要谨慎。不过如果不是专业用户，那么这块屏幕的细腻程度和实际播放效果还是很好。 两个 USB-C 接口。由于目前 Mac 系列的笔记本都已经采用了 USB-C 接口，所以想要连接一些外设可能需要转接设备，但是因为 MacBook Air 只有两个接口，可能会出现接口不够的情况。当然，如果你的工作几乎不需要任何外设，那么也就不需要担心这个问题。 在具体的配置选择上，建议硬盘一定要选择 256GB 以上，千万不要因为价格选择 128GB。128GB 将会大大缩短 Mac 的使用寿命。身边已经有越来多的案例证明，最后更换 Mac 的原因基本上都是因为硬盘存储不足。 总体来看，MacBook Air 适合对于性能没有需求，但对颜值和续航有需求的用户。 相对来说合理的配置： 1.6GHz 双核第八代 Intel Corei5 处理器 8GB 2133MHz LPDDR3 256GB 固态硬盘（以上最好） MacBook Pro 13寸 （2 个雷雳 3 接口） 这是今年推出的新款 13 寸 MacBook Pro。在很多人看来，这其实是原本 MacBook Pro 13寸（4 个雷雳 3 接口）的阉割版本。的确，相较于下面将会介绍的 MacBook Pro 13 寸（4 个雷雳 3 接口）版本，这个版本降低了主频，同时砍掉了 2 个雷雳 3 接口，麦克风音质也有缩水。 但，这让他的价格仅仅只有 9999 元起，和 MacBook Pro 13 寸（4 个雷雳 3 接口）版本的价格差距为 2400 元（相同硬盘容量），并且一个重要信息是： 虽然二者的主频分别是 1.4Ghz 和 2.4GHz，但是二者性能基本相当。跑分结果来看，只是微弱的差距，所以 MacBook Pro 13 寸（4 个雷雳 3 接口） 能处理的任务， MacBook Pro 13 寸（2 个雷雳 3 接口）也一样可以胜任。 那么基本上，2400 元的差价让 MacBook Pro 13 寸（2 个雷雳 3 接口）很值得购买。 所以总结起来，优点是： 极高的性价比。如果你想要用 Mac 处理照片、视频、文档，并且预算吃紧，那么这一款就是最好的选择。 兼顾尺寸和性能。13 寸的笔记本，一直都是市面上比较常见的尺寸类别，重量适中，屏幕适中，移动便携。 缺点： 音响质量在所有 MacBook Pro 中稍逊一筹。 缺少两个雷雳 3 接口。这是我认为 MacBook Pro 13 寸（2 个雷雳 3 接口）最大的问题。因为既然购买了 Pro款，一定是对内容生产有要求的，那么必定需要很多外接设备，所以如果只有两个接口，就需要考虑使用扩展坞来解决这个问题。 购买建议是，切记不要购买 128GB 版本，一定要购买 256GB 版本。不然刚开机，装一些大型软件，例如Photoshop 或者是 Final Cut Pro X之类的就已经满了。 我知道因为价格很相似，很多购买 MacBook Air 的人可能会说，那么我为什么不加一点点钱购买这一款。这种想法很有道理，MacBook Pro 13 寸的屏幕和性能都会好很多，还有 Touch Bar。但还是那句话，你要想清楚自己看重的是什么。如果自己本身对于性能没有要求，只是追求便携、续航和颜值，MacBook Air 依然具有优势。 相对来说合理的配置： 1.4GHz 四核第八代 Intel Core i5 处理器 8GB 2133MHz LPDDR3 内存 512GB 固态硬盘 MacBook Pro 13 寸（4 个雷雳 3 接口） 优势前面其实已经讲过了，那么如果你确定要购买一款 13 寸的 Mac，那么肯定是在两个接口和四个接口之间选择一个，所以这款电脑的优缺点也就明显了，优点是： 四个接口，基本上可以满足各种外设接口，尤其是想要使用 13 寸 Mac 连接显示器的用户更是需要注意，如果你购买两个接口的版本，就意味着显示器和电源以后就再也没有接口连接，所以最好选择这个版本。 音响音质更好。 缺点是相对两个接口版本，价格较贵，要 13899 元起步。 最推荐的配置是： 2.4GHz 四核处理器 8GB 2133MHz LPDDR3 内存 512GB 固态硬盘 Macbook Pro 15寸 如果你是一个视觉或者音乐相关的专业用户，那么 15 寸的 MacBook Pro 就不用说了，应该是身边的人都在用。我几乎身边所有的摄影师朋友或者是搞音乐的朋友基本都是一水的 MacBook Pro 15寸。 优点： 更大的屏幕尺寸就意味着更高的效率，尤其是对于视觉用户来说，15 寸和 13 寸的修图感受完全不一样。 更强劲的性能。目前 MacBook Pro 15 寸最低六核 i7，最高可以选择 8 核，是 Mac 性能的代表。如果你想要一台性能最好的 Mac，那么就是这一台。更重要的是，15 寸的 Mac 是标配独立显卡，这在一些图形渲染的工作上和 13 寸有着本质区别。 更大的触控板。 缺点有： 相对 13 寸不够便携。 起步价格 18199 元，一般用户难以接受。不过对于专业用户来说，我相信因为是生产力工具，基本上价格就不成问题了。 我自己就是 15 寸 Mac 的重度用户，基本上无论是重度的图片修饰，还是影片的 4K 剪辑都可以流畅并高效的完成。目前来说，这也是很多创意用户选择最多的一个类别。 在配置的选择上，虽然 MacBook Pro 15 寸起步就是 256GB，但是对于是生产力级别的机器肯定是不够的，至少是 512GB 起步。我自己是 2T 硬盘，即使如此，同时剪辑 2、3 个视频的时候都有可能捉襟见肘。当然，也可能是因为视频大的原因。而且要注意的是，可能很多人希望通过外挂硬盘来解决，但是对于用来干活的机器，外挂还是会有很多不方便的地方。 所以既然已经花了这么多钱，就不要因为一两千块让自己使用得很不爽。在配置上，虽然我自己是把处理器升级到了 i9，但是并不建议大家这么做。处理速度会快一点，但是不明显，所以我的建议是有预算先升级硬盘、然后内存、然后是显卡。 相对合理的配置： 2.3GHz 八核第九代 Intel Core i9 处理器 16GB 2400MHz DDR4 内存 Radeon Pro 560X 图形处理器，配备 4GB GDDR5 显存 512GB 固态硬盘 iMac 5K 要说在所有的 Mac 中，哪一台最有性价比，那肯定是「买电脑送显示器」的 iMac 5K。你应该经常在各种公司前台看过这台机器，毕竟背部的颜值好。当然，更常见的应该是各种设计公司、摄影公司等等。iMac 5K 本身是一台以「27 寸」大屏幕为卖点的显示设备，它拥有一块： 「分辨率高达 5K ，覆盖 P3 广色域的」专业屏幕。 市面上类似素质的显示器都要上万元，而这台 iMac 5K 的起步价仅有 13832 元，还自带苹果不算便宜的键鼠套装。某种意义上来说，电脑相当于「白送」，所以这也是为什么很多商业机构会使用这款机器的原因。 优点： 拥有一块震撼的 27 寸 5K 显示器。只要你的工作是和视觉相关的，那么这块显示器都可以满足你的要求，无论是影片剪辑还是摄影后期都是利器，绝对是跟普通笔记本完全不一样的体验。 性能够用。因为是台式机，在散热等方面有优势，并且都是桌面处理器，所以一般来说会比相同价位的笔记本性能要好一点。 缺点： 台式机，几乎不具备任何移动性，并且一定要连接电源才可以使用，所以适合固定地点办公。 粗边框。相对于目前的主流屏幕设计，iMac 的设计相对老旧，粗边框一直都饱受诟病。 如果你想要购买 iMac，尽量不要因为省钱而选择 iMac 4K，而是一定要购买 iMac 5K。因为 iMac 4K 的屏幕只有 21.5 英寸，效果大打折扣，并且显得边框更加「粗犷」。当然，还有一条重要的原则： 不要买所谓的融合硬盘，最好是固态硬盘。 其实一台电脑是不是卡顿，很多时候影响因素是硬盘速度，所谓的融合硬盘是少量的固态硬盘和机械硬盘的组合，所以会极大地影响机器的运行速度，尤其是在后期的时候。记住，不要看融合硬盘容量更大就选择，一定要以固态硬盘为主，256GB 可以，512GB 以上最好。 并且对于内存来说， iMac 并不是主要的升级对象，因为 iMac 5K 是支持自行更换内存条的，所以自己购买内存条再添加，可以把更多费用花在硬盘上。而且更换方式非常简单，女孩子只要是简单看一下教程都可以学会。 我自己家里就有一台 iMac 5K 已经服役很多年了，只要是后期修图和重度的影片剪辑基本上都是靠它，绝对是纯正的生产力工具。所以我还是很建议，如果是预算不足，而且真的没有那么需要移动的用户可以先考虑的是 iMac 5K，而不是 Mac 笔记本系列。 Mac mini Mac mini 在所有的苹果电脑里可能是最不为大众所知的产品，这是一条本来已经沉睡了很多年的产品线，突然在去年十月复活了。简单来说，Mac mini 就是一个体积很小的电脑主机，没有任何显示设备，需要你自行连接显示器使用，所以 Mac mini 的价格也相对较低，起步价只有 6331。 但是自行配备显示器这件事，还是很有门槛的，所以对于大多数人来说，我还是建议直接去买 iMac 5K，Mac mini 更适合程序员作为开发工具，而且一般来说这些人群本身也是自带显示器的。 尾声 好了，以上就是我对于目前 Mac 产品线的一个简单梳理。购买一台 Mac 就是像选择一个好伙伴，我们一定要想好预算和需求，不要购买到错位的产品。 目前， Mac 的产品线已经相对来说比较完整，购买渠道也很多，如果你认为官网或者是官方零售店的价格相对来说难以接受，那么大型电商的自营平台也是可以考虑的，价格相对来说可以有一部分优惠。淘宝，尤其是低价淘宝就要警惕了，羊毛终究出在羊身上，翻新做假已经是一条成熟的产业链了。 而如果是学生，是有教育优惠一说的，每年特定时间都是有折扣送耳机，但是今年已经结束了，时间一般都是 8-10 月份这一段时间。对了，最后我还是想要特别说一下： 不要因为自己的预算不够就购买低价的 Mac，Mac 电脑的价格并不是和性能成正比，如果你是一个对性能有需求的用户，预算不足就还请果断放弃，毕竟不能花了钱不解决问题。 还有，如果买了 Mac 就千万别装 Windows，那是在把你的钱打水漂。 作者 | @Derrick Zhang ","link":"https://hesy-zhoulijie.github.io/macbook/"},{"title":"测试版群聊语音/视频上线，macOS 版微信终于不那么残缺了","content":"测试版群聊语音/视频上线，macOS 版微信终于不那么残缺了 微信在 macOS 上的更新进度一直落后于 Windows，其实我已经习以为常了，甚至我开始用 Windows 版微信过于臃肿这样来安慰自己，但知道疫情期间两个月的远程办公，才让我感受到「落后」的悲哀。 没有微信群语音的两个月 尽管公司里已经普遍采用了钉钉作为办公服务软件，但基本只是作为日常人事管理系统使用，绝大部分人沟通还是通过微信。 原本定期的周会，远程办公期间改成了每日上午汇报工作计划，晚间汇报工作完成度，再加上不定期的项目沟通会，我觉得已经非常能折腾了，但使用 Macbook Pro 作为工作机，微信群聊不支持语音才是最让我崩溃的。 每一次群聊会议，都需要从电脑切换到手机上，想要发起群聊还只能从手机上发起；像我习惯带上蓝牙耳机沟通，也不影响家人……你应该能体会那种体验上的巨大割裂感。 废话了这么多，我只是想单纯的表达今天收到 macOS 版微信更新提示的激动，虽然还是 beta 版本，正式版连小程序都没上，估计还有的等。 除了新增群聊语音和视频之外，这版本也加入了新的消息引用样式，样式上类似 Windows/Android 版本，后面会具体演示；其次还有语音自动转文字，这两点也都是近期 Windows 版本微信更新的新特性。 期待已久：微信群聊语音 其实我一直也不大明白，群聊语音或视频功能应该是这类聊天软件核心功能之一，为何微信到现在才开放给 macOS 用户公测。但既然已经来了，那还是只能「真香」了。 唯一没能体验过微信群聊语音的估计现在只有 macOS 用户和网页版用户了吧，群语音/视频人数上限依然是 9 人，大概是觉得九宫格比较好看吧……毕竟微信也没有定义过多人会议场景，尤其是在推出腾讯会议之后。 消息引用样式变更，支持图片 原本微信消息引用在 macOS 上会用得较多，而微信在其他客户端全面优化消息引用样式之后，反而 macOS 端消息引用有点过于简陋。 新版本的消息引用已经修改成跟 Windows、Android 等客户端版本一样的形式，具备比较高的辨识度。 查看引用的文本消息，点击之后会以弹出的消息气泡形式展开，会比手机上全屏展示体验更好。 当然，虽然来的晚，但也是直接支持了图片消息的引用。此外，经测试，语音消息暂时不支持。 语音自动转文字 虽然不支持引用，但也加入了最近在 Windows 版本新增的语音消息自动转文字功能。 对于上班族而言，一天到晚都带着耳机的毕竟是少数，语音消息拿起手机听的话，需要从工作状态中抽离出来解锁手机，而且声音没控制好，指不定女朋友发来什么消息（此处省略几百字……） 语音转文字默认关闭，需要手动在设置中开启。 收到语音消息后会自动转成语音，这点在工作期间还是比较实用的，尤其是经常有人喜欢发大段语音时，戴耳机听也会麻烦，手动转效率不够。 小结 自从有了小程序支持之后，我就基本在 macOS 上使用 beta 版本的微信，目前来看稳定性还不错，没有出现比较大概率的崩溃或者其他难以忍受的问题，而且正式版本已经许久没有新增功能，好歹 beta 版本在功能上是在追赶 Windows 端的，如果对群聊语音或者视频有迫切需求的用户，可以暂时切换到 beta 版本使用。 macOS微信beta版下载： https://dldir1.qq.com/weixin/mac/WeChatMac_Beta.dmg ","link":"https://hesy-zhoulijie.github.io/wechat-mac/"},{"title":"并查集","content":"并查集 洛谷der链接 题面 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 N,MN,MN,M ,表示共有 NNN 个元素和 MMM 个操作。 接下来 MMM 行，每行包含三个整数 Zi,Xi,YiZ_i,X_i,Y_iZi​,Xi​,Yi​。 当 Zi=1Z_i=1Zi​=1 时，将 XiX_iXi​​ 与 YiY_iYi​​ 所在的集合合并。 当 Zi=2Z_i=2Zi​=2 时，输出 XiX_iXi​​ 与 YiY_iYi​​ 是否在同一集合内，是的输出 YYY ；否则输出 NNN。 输出格式 对于每一个 Zi=2Z_i=2Zi​=2 的操作，都有一行输出，每行包含一个大写字母，为 YYY 或者 NNN 。 讲解 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受;即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间(1~3秒)内计算出试题需要的结果，只能用并查集来描述。 (摘自百度) 关于并查集和路径压缩： 现在我们假定 f[i]f[i]f[i] 表示第 iii 个人的老大是谁。 现在我们有甲，乙，丙三个人（分别用 a,b,ca, b, ca,b,c 表示） 假设甲和乙打架了，甲做了丙的小弟。则有 f[a]=bf[a]=bf[a]=b， 后来甲打赢了丙 那么丙就是甲的小弟了。有 f[c]=af[c]=af[c]=a， 但是如果我们这样表示，丙不能直接知道甲，容易自己人打自己人 所以，我们必须直接让丙的大哥变成最大的老大。 定义函数 findfindfind int find(int k){ if(f[k]==k)return k; return find(f[k]); }//find 函数可以直接找到最大的老大 f[c]=find(a); //丙的老大是甲 这时，因为我们要路过他所有的上级，我们也可以顺便使途中经过的人的大哥也变成老大。 //路径压缩 int find(int k){ if(f[k]==k)return k; return f[k]=find(f[k]); /* 即： f[k]=find(f[k]); return f[k]; */ } f[c]=find(a); 简直是太巧妙了！ 而判定两个人的老大是否相等，只需 if(find(a)==find(b)) 就好了。 一些设定： 一个人不能有两个老大。 当已经有老大的人臣服时，老大也将成为胜利的人的小弟。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int i,j,k,n,m,s,ans,f[10010],p1,p2,p3; //f[i]表示i的集合名 int find(int k){ //路径压缩 if(f[k]==k)return k; return f[k]=find(f[k]); } int main() { cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) f[i]=i;//初始化i的老大为自己 for(i=1;i&lt;=m;i++){ cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3; if(p1==1) f[find(p2)]=find(p3); //p3打赢了p2 else if(find(p2)==find(p3)) //是否是一伙的 printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } return 0; } ","link":"https://hesy-zhoulijie.github.io/i_bBwEjyO/"},{"title":" 最全的PDF解决方案","content":"最全的PDF解决方案 Office转PDF 所有的Office2010+ 都具有“导出为PDF”的选项。甚至可以直接另存为PDF！当然你也可以在打印选项中选择Microsoft Printer to PDF PDF 阅读器 Windows 在Windows上的PDF阅读器多种多样，而且全平台的浏览器都可以打开PDF。 ① Adobe Acrobat Reader 相信不少人电脑里都安装了Adobe Acrobat Reader，这是目前使用最广泛的PDF阅读器之一。不过Adobe Acrobat Reader也有缺点，文档打开速度稍慢，只有弹出式注释工具，需鼠标点击方能阅读注释且无法修改注释文字格式。 综合结论：⭐️⭐️⭐️⭐️ 下载地址 ② Sumatra PDF 也是一款好用的PDF阅读软件，体积很小，打开文档速度十分快捷。Sumatra PDF最大优点在于支持搜索PDF文档内容，查找起来十分方便。但标注功能也略有限制。 综合结论：⭐️⭐️ 下载地址 ③ Drawboard PDF 记得时Surface自带的PDF阅读器，Windows应用商城里可下载。Drawboard PDF大概是最好的标注工具了，搭配Surface Pen一起非常好用。官方版请在Microsoft Store中下载。 PJB下载地址 ④ PDF-XChange Viewer PDF-XChange Viewer的文字渲染效果较差，不过它最大优势在于标注特别方便，可任意增减书签，也可以将PDF内容按章节划分标注。 下载地址 Mac 平时也会使用Mac，始终觉得Mac内置的阅读功能太简洁，标注功能严重缺失。 基本没有标注功能，也无法记录阅读进度。 所以Mac里推荐大家使用：Skim Skim也是一款很小的PDF阅读器，但功能却足够强大，标注/阅读/记录一应俱全。 手机 ①Acrobat Reader 安卓 ①PDFelement PDFelemnet更多的是标注、编辑功能，手机上快速处理一些PDF任务还是不错。 安卓 转换格式 All =&gt; PDF 打印 凹凸凹在线转换（还支持200多种除了PDF以外的文件） PDF =&gt; All ilovepdf smallpdf 这次就到这里啦！不足之处也欢迎大家补充指正。 希望有助，顺颂时祺。 ","link":"https://hesy-zhoulijie.github.io/pdf/"},{"title":"WPS2019完全体验指南","content":"WPS2019完全体验指南 — —对不起，我再也不黑WPS了 我们对WPS，有太多刻板印象 用惯了Office的用户（包括我），在谈到WPS的评价可能是到这几个评价。 “WPS没有布尔运算，做不了很多特定的形状。” “WPS太多广告了，不实用。” “WPS很多操作难找，不如office人性化。” “WPS是盗版office吧？？” 其实这些评价，也是大部分人对WPS产生的刻板印象，其实WPS的历史十分地悠久，各方面也一直在优化。 1988年一位叫求伯君的年轻人，在出租屋内敲下了一款文字处理系统——WPS，这也开创了中文字处理时代。 从这样 到这样 在1994年中国办公市场，WPS占据了90%，用户量超千万，要知道当时的微软，在1年前将Word和Excel集合在一起组成了Office。 人性化和部分功能缺失的问题，不可否认曾经的WPS确实做得很不好，以致于在一开始接触PPT的时候，我放弃在WPS操作，选择Office里的PPT。 就这样，我也和很多人一样，走上了一条逢人就说 “删WPS，用Office啦~” 的道路。 但是，上周下载并体验了最新版本的WPS2019后，我决定再也不黑WPS了。 WPS版人性化 相比起Office，在很多地方WPS确实不太合理，但是WPS也有自己闪光的部分，超级人性化的说，在这也做部分介绍，主要包括对齐、文档窗口折叠、字体预览、自带素材库、强大的外部链接。 对齐 在Office里，效率高的小伙伴设置对齐，会先把对齐按钮添加到快速访问工具栏，如果没有设置的话，你就需要手动找到横向分布和纵向分布。 在WPS里我们只需要选中我们需要处理的素材，我们会发现素材边缘会自动生成自动显示对齐框。 哇！ 标签页 在office里，我们时常会夸Excel、Word、PPT，甚至是思维导图，同时三四个文档“ Alt+Tab ”切换处理。 机智的程序员开发了office tab，支持同个文档类型的多开，但是依旧不支持跨文档类型处理，安装使用也是挺费事的。 但是在WPS（2016+），一个软件，全搞定。不得不承认，在颜值方面，WPS2019的界面真的还挺好看的，同时支持多款文档的窗口折叠，office三件套+思维导图+流程图。 字体预览 字体预览，一直是WPS不错的一点，选中文字后我们在选择字体处看到很多种字体预览，可以供我们下载，部分需要会员权限。 辣么多字体，看着就眼馋啊！ 外部软件关联 非常意外的是，WPS突破了原有传统office的三件套模式，串联了包括美化大师、思维导图，便签以及自带了一系列的文档处理转化工具，实现了文档处理一体化。 当然，WPS的部分模板是需要稻壳会员才可以免费试用，如果工作使用频率比较多的话，也可以选择充值，价格也不贵。 云 移动办公的时代，云盘和手机在文档储存与编辑上的作用越来越大，工作效率也越来越高，这部分真的很让我意外，当你下载了APP以后，会发现WPS还有很多很多的神奇操作，可以下载体验~。 手机编辑 我们都知道office不支持手机编辑，而wps则早已开发了一系列的手机端平台，包括手机端WPS支持App，公众号，小程序。 手机端的功能仍是琳琅满目 云存储 WPS的云储存，确实让我眼前一亮，实现了不同电脑、APP、微信公众号，小程序的同步云储存，意味着我们不再需要使用U盘各种复制，只需在电脑或者手机上使用同一个账号就找到WPS即可找到文档。 多端同步它不香吗？ 手机传图 手机传图也是一个很有趣的操作，只需要在WPS中插入选项卡，找到图片选项中的来自手机，扫描二维码以后在手机界面上传图片就可以完成了图片转移了。 手机遥控 只要在手机上安装了WPS，在PPT演示的时候我们可以找到投影宝，扫描电脑端的放映二维码即可实现连接。通过左右滑动可以控制页面播放顺序，在没有演示笔的时候可以考虑用手机遥控。 这里用一张官网上的图 线上会议 目前手机语音会议为免费使用功能，大家可以体验一番，不过WPS还是好多功能需充值~ AI in WPS 这里的AI是人工智能哦。 其他玩法 切换动画 新闻联播 在WPS里，发现了一个好玩的切换动态效果。 支持插件 曾经有人会说office高效是因为兼容得了很多得插件，其实这几年WPS也支持安装islide、Pa口袋动画、美化大师等多个插件。 总结 Office和WPS谁强谁弱，谁更好用的问题也是一直被人们讨论。 不得不否认，至今依旧有部分设计性功能是Office专有，而WPS无法比拟的，例如：布尔作品，3D玩法，更多样式的动画效果等。 尽管众多的PPT爱好者都崇尚Office，但是不得不否认WPS也有属于它的『办公』优势，也收获了众多粉丝。 ①基本满足了职场人士办公需求； ②体积小，官网下载不到100M； ③下载完全免费，无需购买序列号； ④安装方便，不会出现太多版本冲突问题； ⑤模板库，Ai生成等操作完全为现代人定制——懒人设计。 对工具的选择，取决于能否顺利解决我们的工作，至于使用office还是wps，大家可以根据自己需要选择。 我个人总结Office与WPS就是： 设计性，Office完胜；功能性，WPS够用。 分享完毕，希望有助~ ","link":"https://hesy-zhoulijie.github.io/wps/"},{"title":"让PPT变精致的秘密，都在这篇文章里","content":"让PPT变精致的秘密，都在这篇文章里 在PPT设计中，我们常常会使用到图标，用以修饰画面和辅助文字说明。作为PPT中的“增色剂”，图标能够让PPT更有视觉效果，因此也深受同学们的喜爱。 但是，PPT中的图标有千千万万， 为什么我们要掌握图标？ 图标的几种分类你都知道吗？ 我们怎么快速找到好看又合适的图标？ 是不是我们把图标插进去幻灯片页面就代表我们掌握了呢？ 下载下来的小图标怎么做能够更加生动有趣？ 带着这几个灵魂拷问，今天小醒目就来跟大家聊聊关于图标那些你不得不知道事儿。 图标到底有多重要呢？ 1.辅助文字说明 在演示设计中我们常听到一句话“字不如表，表不如图”，说的就是图的重要性。 图标作为“图”的一种表现形式，被我们广泛应用在PPT当中，在里面充当“指示内容”的作用。 其实不只是PPT设计，我们经常接触的APP界面，也是依靠图标提升用户对信息的感知度： 而在PPT中，图标通常伴随短文字一起出现，达到图与文的连贯理解效果，让观众一目了然同时图标也可以 2.提升幻灯片的画面感 图标除了能够辅助文字说明之外，它还能起到一个很重要的功能就是美化幻灯片。特别在幻灯片文字比较少的时候，图标就起到很好的补充画面的作用了。 比如： 同一个图标，不同的形态 还是上面的文字，可以化用不同的图标 可以添加背景 还可以用渐变色 真香。 在这里也只安利一个网站 阿里巴巴矢量图标库 http://www.iconfont.cn/ 这个网站是现在质量最高的图标库，里面的图标不仅数量庞大、风格统一，而且美观也能符合现在PPT设计的潮流，光这几点就可以帮我们省去很多筛选图标的时间了。 此外，阿里巴巴矢量图标库还提供无限量免费下载，这对于需要在幻灯片中插入大量图标的同学来说简直是福音！ 在下载选项中，这个图标库还很贴心提供了自选颜色，免得同学们因为难以更改颜色而放弃一个心仪的图标。 除此之外，阿里巴巴矢量图标库还提供现在主流的几种格式让大家下载，像最通用的PNG格式，以及下载后还能重新编辑的SVG/AI格式。 像SVG格式，如果同学们用的是Office365的话，可以直接拖进PPT中，右键取消组合两次就可以自由编辑了 图标的颜色也很重要哦！ 配色很大程度上决定了PPT长什么样子。使用阿里巴巴图标库的SVG格式导入的图标，取消组合后就可以愉快的编辑啦！ 自己调整完配色，就会很好看哒，比如说这两个 干巴巴的图标很难看，如果这样呢？…… 哇！好美！ 还有呢！ 这是针对深色线性或者填充图标使用的小技巧，这两种图标能给人带来简约的感觉，但看多了会觉得单调，这时候我们在图标加上一个小色块作为点缀，小图标瞬间就有点“活泼”的感觉： 再来讲一种优化的方法—长投影 先把图标备份一遍 然后放大到400%，Cmd+D（Ctrl+D）复制一个，把新复制的图标平移到原图标斜下方45°并且与原图标无限接近的位置。 无限摁Cmd+D（Ctrl+D）。觉得阴影长度适合就可以停止复制粘贴了，然后我们把这份投影初稿全选，点击选项卡**“格式”——合并形状——结合**，这样我们的长投影就做好了！ 想调整字体？ 也可以哒 首先插入文本框，随便敲一点东西。 把它用个举行盖住，全部选中。 把蓝色的矩形删掉 wohoo！ 不知道大家看到这里有没有对PPT中小小的图标有个新的认识，其实图标作为一个独立的设计元素，真的值得每个PPTer去重视的，而且图标也还有很多玩法有待挖掘，比如通过虚实大小去表现内容重要程度，或者和文案结合。 这期的分享就到这里了，希望对大家有所帮助，我们下期再见。 本篇的PPT素材请自行下载 让PPT变精致的秘密，都在这篇文章里-配套PPT.pptx 密码：uu62 ","link":"https://hesy-zhoulijie.github.io/icon/"},{"title":"微信是个好东西，但是你会用微信多少功能呢？","content":"微信是个好东西，但是你会用微信多少功能呢？ 消息换行 用过QQ电脑版的盆友都知道QQ电脑版的换行是Ctrl+⏎（⌘⏎），但是微信呢？如果你要尝试每一行发一条消息，然后这样做，相信我他会跟你绝交的！ 哼～～ 其实使用Shift+⏎（⇧⏎）就可以换行啦！ 而且Shift+⏎在大多数文字编辑软件中都能用滴！ 巧用“收藏” 首先强调一下，不论是在PC还是手机，收藏大小总共只有 2G2G2G！ 首先看看笔记 同时可以添加标签进行整理 更改设置 把自己几个G的文件别存在C盘了！ 聊天中的快捷方式 引用功能 截图工具 同步消息 经常在PC微信和手机微信间切换的伙伴一定深有感触，PC微信虽然方便，但有时候聊天记录无法同步，还是得掏出手机，来回切换十分影响效率。 其实微信是可以同步聊天记录的，只是不像QQ始终云端同步而已。 操作方法也非常简单：电脑端点击左下角，选择备份与同步。 这样就OK啦！ 设置自带表情包的昵称 相信大家平时在微信群聊的时候都遇到过这种情况，@某人时居然会有表情掉落！这个看似神奇的操作，其实并不复杂，设置起来非常简单，只需要在自己的昵称后面添加一些后缀就可以了。常见的有这些 么么哒： จุ๊บ 星星代码：ฉันคิดถึง 蛋糕：สุขสันต์วันเกิด 一些损人的技巧 //fullexit （发送出去）强制退出微信登录 :recover 搜索它，会跳出一个“微信修复工具” 就像这样（多平台适用） 这里还是有很多骚操作的！ ","link":"https://hesy-zhoulijie.github.io/wechat/"},{"title":"博客阅读指北","content":"点击这个“归档”查看所有文章 历史博客备份： 20201005 ","link":"https://hesy-zhoulijie.github.io/PjSoP3sCF/"},{"title":"文件共享方法总结","content":"文件共享方法总结 写在前面 笔者家中有2台电脑，但是在两台电脑之间共享文件是一个很麻烦的事情，所以通过对Win10和Mac OS X 13的充分研究整理，完成了本份攻略 方法1 自带文件共享 效果： 这种方法在Windows上的实现方法： 然后到Mac上 但是IP地址在每台电脑上都不一样 所以我们就需要金坷垃ipconfig! 具体的IP取决于你用的网络连接种类，如果是以太网就看以太网的，WLAN就看WLAN的。 然后在Mac上点进去，输入用户名和密码，** 这里要输入的是密码，不是PIN！！！ ** 然后直接Ctrl+C，Ctrl+V进行复制粘帖就可以啦！！！ 方法2 远程登陆 首先在Mac的找到“请键入“ssh ***.***.***.***@******的东西” 然后到Powershell里面打开就可以了。 反过来，用方法一中的本地ip也可以 在Mac上用ssh登陆Windows ","link":"https://hesy-zhoulijie.github.io/file_share/"},{"title":"调整软件设置，让 PPT 更符合你的使用习惯","content":"调整软件设置，让 PPT 更符合你的使用习惯 幻灯片大小 幻灯片大小分成nnn种，可以自定义的哦。 我这里用的是Mac版本的Office365，Windows应该绝对差不多 从这里可以发现，各种大小都可以，所以建议大家按照需求进行自定义。 此外，如果你的 PPT 有其他需求，也可以选择「自定义幻灯片大小」。里面除了可以设置「信纸」、「A4 纸张」或「横幅」等特别的格式大小以外，也可以自定义幻灯片的宽度和高度，以及调整幻灯片或备注的方向（纵向、横向）等。 关键来了，有的时候你需要在编辑时调整大小，就会看到这个窗口 建议大家选择缩放。 字体 Office系列的默认字体是等线，但是这种字体实在是太丑了！ 我们可以通过万能的百度下载到无数的字体，但是PPT的时候还是需要一个个修改，让人苦不堪言。 有没有想Keynote的字体更改工具呢？那是当然。 在我的版本中，可以直接使用字体更改工具。 但是有人没有这个功能啊，怎么办呢？ 可以使用字体更改器，在设计里点“变体”，下面就有字体选项卡了。 在这里找到自己喜欢的字体。我比较喜欢这个 更重要的是，这里一旦更改完，你插入的所有字体都是这个！ 颜色 和字体差不多，在同一个地方还有“颜色”的选项卡，颜色同时可以自定义的哦。 比如说上面```Custom``就是我自定义的哦。 快速访问工具栏 很多人都抱怨过Powerpoint没有自定义的功能，其实是你不知道在哪里。 就是这里！！！（在最上面） 点开最右边的按钮 这里可以把自己喜欢的小功能添加在这里 当你添加的功能稍微多了点，就会发现窗口上方挤着一整列工具，且使用时还得将鼠标移到窗口上方，颇不方便。 此时，你可以拉开「快速访问工具栏」最右边的选单「自定义快速访问工具栏 - 在功能区下方显示」，就可以将这一列工具移到功能区的下方了。 备注：只支持Windows！！！ 在设置好「快速访问工具栏」之后，你可以在「其他命令 - 导入/导出」，把专属于你的「快速访问工具栏」导出自定义文件。 这可以让你在另一台计算机使用 PPT 时，能够直接导入文件，而不用再重新设置「快速访问工具栏」。 ","link":"https://hesy-zhoulijie.github.io/powerpoint-usage/"},{"title":"使用macOS Catalina的面板编辑器进行便捷控制","content":"使用macOS Catalina的面板编辑器进行便捷控制 面板编辑器入门 1. 什么是面板编辑器 面板编辑器是用来自定义面板（虚拟键盘）的。 路径： /System/Library/Input Me thods/Assistive Control.app/Contents/Resources/Panel Editor.app 重要！！！只有macOS Catalina有！！！ 重要！！！只有macOS Catalina有！！！ 重要！！！只有macOS Catalina有！！！ 2.如何使用 沿袭了Mac软件简单易懂的优良品质，可以直接用的哦！（是不是很香） 按左上角的添加面板就可以了。 因为面板不能直接链接到软件的菜单，只支持这些 于是我们需要先添加快捷键然后才能添加。 关于如何添加快捷键，请参考文章Mac如何自定义快捷键传送门 完成快捷键添加后，这里我以前往桌面来举例子 在操作中选中按下按键，输入快捷键⇧⌘D(Shift+Command+D) 点击保存，然后就可以用啦！哦，别忘了，记得选中在那些应用中有效（上面）哦 打开虚拟键盘后，点击左上角的设置按钮，在自定面板中找到你刚刚用的名字的选项，然后就大功告成啦！ 高级控制 可以通过macOS的辅助功能进行高级控制，比如启动进程，系统事件（下图）等等。 同时也支持打开App，运行Applescript等等，简单来说，啥都支持。 使用案例 这是我在使用腾讯课堂的时候用的面板 其他的功能会陆续更新 ","link":"https://hesy-zhoulijie.github.io/面板编辑器/"},{"title":"Mac如何自定义快捷键","content":"Mac如何自定义快捷键 写在前面 本页面使用sm.ms图床，网速比较慢，大约需要加载5秒，请稍后。 Mac上不像Windows有很方便的定义快捷键的工具，于是我们就需要通过系统偏好设置来自定义。 Mac如何自定义快捷键 写在前面 本页面使用sm.ms图床，网速比较慢，大约需要加载5秒，请稍后。 Mac上不像Windows有很方便的定义快捷键的工具，于是我们就需要通过系统偏好设置来自定义。 第一步：进入需要自定义的应用 这里举个例子，我要在Microsoft word里添加一个绘制横排文本框的快捷键：⌘+t 首先我在菜单中找到“文本框” 一定要记住他的名字！！！ 第二步：打开系统偏好设置 这样就OK了 来看看效果（关注左下角软键盘） 是不是很香！ ","link":"https://hesy-zhoulijie.github.io/mac-shortcut/"},{"title":" Keynote完全指南","content":"Keynote完全指南 如何用keynote做一个PPT 首先打开Keynote软件,会看到这样的界面. 点击新建文稿, 这模板多得可以啊. 我就随便选一个. 主界面和Microsoft Powerpoint差不多呢! 打开来:字体很漂亮,但是没法看啊(QaQ) 所以,第一步: 更改字体 这里可以把全PPT的主题字体修改成自己想要的 这样就好看多了吧 接下来看看有什么样的版式呢? 每个模板都有这些版式的哦 接下来就可以开始写了 突然发现,这里好像不能直接画图形诶??? 是的,每一次新建一个图形就会给你画出一个1:1的这个图形 如果插入了图像也不要紧 都可以完成编辑. 这里的编辑遮罩就相当于裁剪啦 Keynote也同样支持插入图表 而且很好看,最重要的就是他不需要打开另外的软件就可以编辑数据!!! 他不需要打开另外的软件就可以编辑数据!!! 他不需要打开另外的软件就可以编辑数据!!! 是不是很香? 如何添加动画??? Keynote的动画比Powerpoint的好一百倍! (进入动画) (强调动画) (退出动画) 哇! 太帅了!!! 每个效果都有不同的选项 举个例子🌰 香不香??? 各种动画都很酷炫 比如这个 总共只有一个动画,叫做神奇移动 我肯定没吭你 这里的坑很深,不是一天两天能讲清楚的. 大家可以在bilibili上搜索关于keynote动画的更详细内容 如何演示keynote 因为keynote所有专门的动画都必须要用.key文件才能放映,但是只有Mac有keynote,于是我们有三种方法进行分享 iCloud 将文件上传到iCloud,可以在网页端直接编辑,也可以远程下载或者放映 Keynote Live 支持在本地放映云端观看 然后就可以远程观看了,只不过观看端加载很慢 观看端是这样的 记得放映的时候要选择上面的那个选项哦 导出视频 在这里选择导出格式和时间控制然后直接打开视频文件就OK啦!!! 最后 PPT可以直接在Keynote里打开,替换字体就很香了. 其他的教程我会陆续发在这里. 百度上有很多的keynote模板,可以自行下载. ","link":"https://hesy-zhoulijie.github.io/keynote/"},{"title":" GitHub博客+gridea的搭建指南","content":"GitHub博客+gridea的搭建指南 系统环境 macOS Sierra+ Win7+ GitHub部分 首先注册GitHub账号 然后进入这个仓库 （这是我的仓库） 接着打开Grieda 先点远程，在这里输入自己的账户信息 然后直接点击新建就可以愉快的写作了 最后点发布，OK了！ ","link":"https://hesy-zhoulijie.github.io/Gridea/"},{"title":"高效使用Chrome浏览器，你可能不知道的10个技巧。","content":"高效使用Chrome浏览器，你可能不知道的10个技巧。 转载自 工具狂人 浏览器，是通向精彩网络世界的一个重要通道，基于此，它也占据了电脑的大部分使用时间。 为增强浏览器的功能，我们会为它安装各种插件，但其实除了从外部的插件入手，我们还可以通过掌握一些浏览器使用技巧，来提升其使用效率。因此，今天的这篇文章，我从使用浏览器可能会遇到的问题出发，整理了一些对应的解决方法，希望对你有帮助。 另存为PDF 以保存微信公众号文章为例，在浏览器中打开文章，右击页面，选择「打印」。在弹出的窗口中，将「目标打印机」更改为「另存为 PDF」。更改为另存为 PDF 后，下方的按钮会由「打印」自动更改为「保存」，点击保存，就可以 PDF 文件的格式保存网页内容。 网页存档 除了将网页保存为 PDF 文档，我们还可以将网页保存为它原本的格式「HTML」。在网页的空白处右击页面，选择「另存为」，保存格式可选择 mhtml 或 html，区别在于： 保存为 html 会额外生成一个文件夹，而 mhtml 会将所有元素保存在同一个文件中。 使用剪藏 为方便在不同设备间查看保存的网页内容，我最常使用的方法，还是将内容保存到笔记软件中。 对于电脑端的浏览器，将网页内容保存到笔记软件，需要先安装对应的浏览器插件，如印象笔记的「Clip to Evernote」或有道云笔记的「有道云笔记网页剪报」。 网页长截图(Chrome内核专用) 和使用手机一样，在电脑上浏览网页，有时也存在截取长图的需求。 除了为电脑安装第三方截图软件，其实我们还可以使用浏览器自带的功能，来获取长截图。 使用 F12 打开浏览器「开发者工具」，使用快捷键 Ctrl + Shift + P 打开命令面板，输入「full」，下方会返回「捕获全屏」的命令。 点击运行命令「Capture full size screenshot」，就可以得到当前网页的长截图。 解除禁止🈲️复制 有些网站出于保护内容的目的，如 B 站的部分专栏文章等，会将网站的内容设置为禁止复制。 除去侵犯他人权益的动机，有时我们复制一些内容，纯粹是出于学习或交流的目的。 对于禁止复制的内容，我们最常用的应对方法可能是截图，除此外，我们还可以使用两种方法来解除网站的禁止复制。 a) 关闭javascript 使用 F12打开浏览器「开发者工具」，点击开发者工具右上角的「 ⋮ 」按钮，选择「Settings」。在打开的页面中，找到 Debugger 下的「Disable JavaScript」选项，将其暂时勾选，禁用浏览器的脚本功能。此时，使用 F5 刷新当前网页，原本不支持复制的内容就可以随意复制了。 b) 复制HTML 复制 HTML 中的文本内容，仍然需要用到「开发者工具」，打开之后，点击左上角的「箭头」图标，切换到元素选择工具。 切换到选择工具后，将鼠标移动到你想复制的内容上方并单击，在右侧的开发者工具窗口，可以看到当前文本在 HTML 中的位置，双击文本内容，右键选择「复制」。 如此一来，通过这种方法，也能解除网页禁止复制的限制。 6. Chrome的实验性功能flags 首先声明，这里的 flags 并不是你年初立下的各种 flags，它指的是 Chrome 处于实验阶段的功能，大部分功能还未在正式发布的 Chrome 中启用。在 Chrome 地址栏中，输入 chrome://flags ，打开的页面就可以看到 Chrome 的所有实验性功能。这个页面不支持chrome自带的翻译,所以需要安装插件进行翻译哦 7. 网址前后缀添加 a) 下载油管video https://www.youtube.com/...=&gt; https://www.ssyoutube.com/... b) 下载B站视频 https://www.bilibili.com/...=&gt;https://www.ibilibili.com/... =&gt;https://www.bilibilijj.com/... c) 各种工具 https://*.*/...=&gt;https://wn.run/*.*/,,, eg. https://www.bilibili.com/* =&gt;https://wn.run/www.bilbili.com/* 写在最后 本文介绍的一些技巧，如解除网页禁止复制、下载网站视频，如果用于不正当用途，会存在侵犯他人权益的可能，建议使用时仅出于学习和交流的目的。 除了本文介绍的内容，你还知道浏览器的其他使用技巧吗？ 欢迎在留言区与大家分享。 以上，就是本次想和你分享的内容。 ","link":"https://hesy-zhoulijie.github.io/Chrome浏览器/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hesy-zhoulijie.github.io/hello-gridea/"}]}